[{"title":"签名部分优化-GAUSS-04","date":"2025-02-27T11:08:20.000Z","url":"/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-GAUSS-04/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"GAUSS函数具体优化采样前处理经过前三次分析，我们不难发现，由于算法内部比较难以优化，事实上目前最可行的方案就是并行化四个SHAKE实例的处理，这也是开发者留下的天然的用于AVX2优化的部分。 因此，下面这段我们暂且全部保留。 接下来，首先把高斯分布表展开成AVX2向量： mm256_set1_epi64x 是 Intel AVX 指令集中的一个内联函数，其核心作用是将一个 64 位有符号整数（long long 或 __int64 类型）重复填充到 256 位 SIMD 向量寄存器（__m256i 类型）的所有 64 位元素中。 此处需要说明一下hi_len和lo_len变量，事实上，二者是由这一段代码定义的： 其实这里的define写的挺莫名奇妙的，因为无论是256还是512或是1024的 SG_MAX_LO和 SG_MAX_HI都是一个固定的常数，也就是20&#x2F;26&#x2F;26和8&#x2F;10&#x2F;10，暂不清楚为什么要采取这样的除法定义，或许是当时写的时候为了方便泛用？ 接下来，我们初始化四个SHAKE上下文。 接下来的flip操作需要进行一定的修改，我们发现开发者已经为优化预留出了结构 shake_x4_context 和函数 shake_x4_flip 因此我们直接使用就好。 主采样循环首先要理解一下原来的union结构的含义。 这个union结构的作用是向内存写入8位的变量b，然后使用16位的w和64位的q来进行访问，通过对一段内存的共享和视图访问来解决了复制造成的内存占用和时间开销。虽然在源代码中开发者根本没用到这一点，使得这一写法显得意义不明，但是在优化过程中我们却可以使用这个特点。可以在调用 shake_x4_extract_words(&amp;scx4, buf.q, 5) （没错，开发者也在 sha3.c中实现了这个函数）时，数据被写入 q 数组（视为 5 个 64 位字），然后通过 y 数组将数据视为 __m256i 向量，直接用于 AVX2 指令。接下来的指令是 shake_extract的AVX2化版本 shake_x4_extract_words，我们有必要了解一下这个函数的作用： shake_extract()：单实例数据提取功能此函数用于 单个SHAKE实例的挤压阶段，将内部状态中的数据按字节提取到输出缓冲区。 核心逻辑 状态指针管理： dptr：当前处理位置（字节级偏移）。 rate：海绵结构的“速率”（单位：字节），即每次挤压阶段输出的最大数据量。 块置换触发： 当 dptr == rate 时，调用 process_block(sc-&gt;A) 执行 Keccak-f置换（哈希核心操作），生成新的状态数据，并重置 dptr 为0。 逐字节提取： 通过 sc-&gt;A[dptr &gt;&gt; 3] 定位到对应的64位字（dptr &gt;&gt; 3 等价于除以8）。 通过 (dptr &amp; 7) &lt;&lt; 3 计算字节在64位字内的偏移（左移3位等价于乘以8，得到比特偏移）。 示例：若 dptr = 5，则从 sc-&gt;A[0] 中提取第5个字节。 应用场景 生成任意长度的哈希输出（如SHAKE-128&#x2F;256）。 shake_x4_extract_words()：四实例并行提取功能此函数用于 四个并行SHAKE实例的挤压阶段，批量提取64位字到目标数组，常用于SIMD优化或批量哈希计算。 核心逻辑 四实例状态管理： 每个实例的状态存储在 scx4-&gt;A 中，内存布局为 四个连续的状态块，每个块占25个 uint64_t（对应SHA-3的1600位状态）。 块置换触发（并行）： 当 dptr == rate 时，对四个实例依次调用 process_block()，执行Keccak-f置换。 批量提取64位字： 每次从四个实例的状态中提取一个64位字（dptr &gt;&gt; 3 定位到字索引）。 示例：若 dptr = 8，则从每个实例的 A[1]（第二个64位字）提取数据。 关键设计 内存布局：四个实例的状态在内存中连续分布，间隔25个 uint64_t，便于向量化操作。 高效提取：每次循环提取4个实例的64位字，直接写入目标数组，减少冗余操作。 应用场景 高性能计算（如同时生成多个哈希流）。 与SIMD指令（如AVX2）结合，加速批量哈希提取。 顺便扩展一下Keccak-f 置换操作的细节，但在此处我们不需要优化它的实现。 Keccak-f 置换操作是 SHA-3 哈希算法家族（包括 SHAKE、SHA3-256 等）的核心组件，也是 Keccak 海绵结构的关键步骤。它通过多轮非线性变换对固定大小的内部状态（如 1600 比特）进行混淆和扩散，确保哈希输出的不可预测性和抗攻击性。 1. Keccak-f 的基本结构 状态表示： Keccak-f 将内部状态视为一个 5×5×w 的三维数组（w = 2^ℓ，例如 w=64 对应 1600 比特状态）。每个元素是一个 w 比特的“车道（lane）”。 SHA-3 使用 b=1600 比特（即 w=64, 5×5×64=1600）。 状态可视为 5x5 的矩阵，每个元素是一个 64 位整数。 轮数： Keccak-f[b] 的轮数 n 取决于状态大小 b： b=1600（SHA-3）时，轮数 n=24。 每轮包含 5 个非线性变换步骤（θ, ρ, π, χ, ι）。 2. Keccak-f 的 5 个步骤每轮操作对状态按顺序执行以下 5 个步骤： (1) θ（Theta）: 线性混合 目标：增加状态的扩散性（Diffusion）。 操作：每个比特的值受其相邻列和行的比特异或（XOR）影响。 计算每列的奇偶校验（Parity）并异或到相邻列。 公式：A′[x][y][z]&#x3D;A[x][y][z]⊕(⨁y′&#x3D;04A[x−1][y′][z]⊕⨁y′&#x3D;04A[x+1][y′][z−1]) (2) ρ（Rho）: 比特循环移位 目标：引入比特位置的混乱（Confusion）。 操作：对每个车道（lane）进行固定偏移量的循环左移（Rotate）。 偏移量由预定义的表格决定，例如 A[1][0] 循环左移 1 位。 (3) π（Pi）: 行置换 目标：打破对称性，增强非线性扩散。 操作：将 5x5 矩阵的行按固定规则重新排列。 新位置 (x&#39;, y&#39;) = (y, (2x + 3y) \\mod 5)。 (4) χ（Chi）: 非线性变换 目标：引入非线性，抵抗线性密码分析。 操作：对每行应用逻辑运算，使用 AND 和 NOT 操作。 公式：A′[x][y]&#x3D;A[x][y]⊕((NOT A[x+1][y]) AND A[x+2][y]) (5) ι（Iota）: 轮常量异或 目标：打破每轮的对称性，防止固定点攻击。 操作：在特定位置（A[0][0]）异或一个预定义的轮常量（Round Constant）。 轮常量由伪随机算法生成，每轮不同。 3. Keccak-f 的安全性与设计特点 抗攻击性： 通过多轮非线性步骤（尤其是 χ）抵抗差分和线性攻击。 ι 的轮常量防止攻击者利用对称性简化计算。 效率： 位操作（AND&#x2F;XOR&#x2F;Shift）在硬件和软件中高效实现。 并行性：θ、ρ、π 步骤可并行计算（χ 需顺序处理）。 灵活性：Keccak-f 支持不同状态大小（如 200、400、800、1600 比特），适用于多种场景。 4. Keccak-f 在海绵结构中的角色在 海绵结构（Sponge Construction） 中，Keccak-f 负责 吸收（Absorb） 和 挤压（Squeeze） 阶段的处理： 吸收阶段： 输入数据分块与状态异或，每填充一个块后执行 Keccak-f 置换。 挤压阶段： 从状态中提取输出数据，每次提取后可能需要执行 Keccak-f 置换以生成新状态。 5. 示例：SHA3-256 中的 Keccak-f 参数： 状态大小 b=1600 比特（5×5×64）。 轮数 n=24。 流程： 输入消息填充为 r=1088 比特的块（速率 rate）。 每个块异或到状态的前 r 比特，执行 Keccak-f[1600] 置换。 最终挤压出 256 比特哈希值。 6. 对比其他哈希函数的核心操作 哈希函数 核心操作 特点 SHA-3 Keccak-f 置换 基于比特操作，抗量子攻击，高灵活性 SHA-2 压缩函数（加法、布尔函数） 依赖算术运算（如模加），易受侧信道攻击 BLAKE3 置换 + 树形结构 高度并行，SIMD 优化 总结Keccak-f 置换通过 多轮非线性变换 和 比特级混淆，为 SHA-3 提供了极高的安全性和效率。其设计平衡了抗攻击能力与实现灵活性，成为后量子时代哈希算法的标杆。 内部采样循环接下来要优化的部分是这一段，也是最关键的一段： 因此我们要一步步来看。 奇偶列构建 在这里我们可以细致的讲一下这些变量为什么要这么计算，由于开发者极其随意的命名风格，这些变量很难看出到底是什么和怎么计算，这也困扰了我相当长一段时间。 变量v v实际上是全局索引，它的计算方式是 size_t v = u + (j &lt;&lt; 2) + k 其中： u：外层循环变量，表示当前处理的样本块起始索引（步长16）。 j：外层循环变量（0~3），对应四个并行的SHAKE实例。 k：内层循环变量（0~3），对应每个SHAKE实例生成的4个样本。 所以我们得知这里的处理逻辑是： 每个SHAKE实例每次生成 4个样本（通过 k 循环）。 四个SHAKE实例（j 循环）共生成 16个样本（4实例 × 4样本）。 因此，u 每次递增16，处理下一个样本块。 而全局索引 v 的构造： (j &lt;&lt; 2) 等价于 j * 4，表示每个SHAKE实例的样本偏移。 u + (j &lt;&lt; 2) 表示当前SHAKE实例的起始索引。 k 表示当前实例内的样本偏移。 最终：v 的取值为 0, 1, 2, ..., 2n-1，覆盖所有样本。 数组t t 数组是一个 紧凑的位数组，存储每个样本的 奇偶列选择位（pbit），即： pbit = 0：选择高斯分布表的偶数列。 pbit = 1：选择高斯分布表的奇数列。 存储方式 每个样本占1位： 每个样本的 pbit 只需1位（0或1），因此一个字节（8位）可以存储 8个样本 的 pbit。由于我们总共也就只要处理四个SHAKE实例即16个样本，因此两字节大小的t数组实际上就已经足够了。 索引计算： 字节索引：v &gt;&gt; 3（等价于 v / 8）。 位偏移：v &amp; 7（等价于 v % 8）。 变量pbit 提取奇偶列选择位pbit: uint32_t pbit = (t[v &gt;&gt; 3] &gt;&gt; (v &amp; 7)) &amp; 1; 例如，样本 v = 9： 字节索引：9 &gt;&gt; 3 = 1 → 使用 t[1]。 位偏移：9 &amp; 7 = 1 → 提取 t[1] 的第1位。 示例 假设 t 数组内容为： 样本 v = 0：t[0] 的第0位 → 0b10101010 &gt;&gt; 0 &amp; 1 = 0。 样本 v = 1：t[0] 的第1位 → 0b10101010 &gt;&gt; 1 &amp; 1 = 1。 样本 v = 9：t[1] 的第1位 → 0b11001100 &gt;&gt; 1 &amp; 1 = 0。 在读懂这一部分之后，大家不免产生一个问题，那就是这个pbit变量明明只有0和1两种情况，一个bool类型也能表示了，为什么要用uint32_t类型？这不是浪费空间吗？答案是确实是这样的，取32位的作用纯粹是为了计算下面的两个掩码（没错，p_odd和p_oddw都是掩码，虽然odd的翻译是奇数，但我实在没想明白odd和掩码有什么关系）。 这行代码的目的是将布尔值 pbit（0或1）转换为一个 全0或全1的64位掩码，具体规则如下： 若 pbit = 0，则 p_odd = 0x0000000000000000（全0）。 若 pbit = 1，则 p_odd = 0xFFFFFFFFFFFFFFFF（全1）。 实现原理 类型转换： (uint64_t)pbit：将 pbit（0或1）强制转换为64位无符号整数。 此时结果为 0x0000000000000000 或 0x0000000000000001。 取负数操作： 在补码表示中，负数 x 等价于 ~x + 1（按位取反后加1）。 当 pbit = 0 时： 0x0000000000000000 = 0x0000000000000000（全0）。 当 pbit = 1 时： 0x0000000000000001 = 0xFFFFFFFFFFFFFFFF（全1）。 在上面的内容都能理解后。我们就可以得到AVX2指令集下的优化方案了。 首先，我们一次要并行处理四个SHAKE实例也就是十六个样本，因此可以直接取消掉j层循环，16个样本对应t数组的两个元素，u的步长是16所以取 t[(u &gt;&gt; 3) + 0]和 t[(u &gt;&gt; 3) + 1] 就可以得到两个字节了，但具体怎么使用这两个奇偶位还需要结合后面的过程来分析。 高斯分布查表"},{"title":"签名部分优化-GAUSS-03","date":"2025-02-27T11:08:15.000Z","url":"/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-GAUSS-03/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"SHAKE类型经过之前的工作，我们了解到，GAUSS函数实际上的操作对象是一个 shake_context类型的变量。如果要对这个函数进行优化，那么势必就要了解一下这个 shake_context到底是什么，该变量定义在 sha3.h中： 这个结构体包含以下成员： uint64_t A[25]; 这是一个包含 25 个 uint64_t 类型元素的数组。uint64_t 是一个无符号 64 位整数类型，通常用于存储较大的整数值。 unsigned dptr; 这是一个无符号整数类型的变量，通常用于表示某种指针或索引。 unsigned rate; 这也是一个无符号整数类型的变量，通常用于表示某种速率或比率。 SHAKE初始化接下来我们要跟踪GAUSS函数中对shake_context变量的操作来确定我们到底该在哪一步开始优化工作。我们关注到在四次循环中，第一步都是： 这一步的目的显然是初始化 shake_context，观察循环结构可以知道，该过程需要重复四次，那么我们有没有可能把这个四次的过程利用AVX2变为一次呢？这需要查看具体的 shake_init函数。 我认为完全是可以的，这里的初始化实质上是一个重复的过程，在传入参数确定只可能为256&#x2F;512&#x2F;1024的情况下，rate和 dptr的初值实际上是确定的，而A数组的所有值都为0，这只需要使用AVX2的 setzero指令也可以完成。同时，从 rate和 dptr的初值来看，两者分别是当前状态缓冲区的写入位置和SHAKE 算法的“速率”（每个块的大小，单位：字节）。 Inject&amp;flip步骤接下来的一步是这样的： 我们观察到，之前的代码生成随机种子时只生成了40位，但预备位却有41位，而在此处才加入了第41位，也就是循环变量，可能是用于禀明shake实例的顺序?但这个并不重要，我们要关注的是接下来的 inject和 flip函数： 位操作 sc-&gt;A[v &gt;&gt; 3] ^= (uint64_t)buf[u] &lt;&lt; ((v &amp; 7) &lt;&lt; 3); 解析： v &gt;&gt; 3：将字节位置 v 转换为 uint64_t 数组的索引（每个 uint64_t 占 8 字节，右移 3 位等价于除以 8）。 (v &amp; 7) &lt;&lt; 3：计算在 uint64_t 中的位偏移（每字节 8 位，7是0b0111，&amp;7相当于取模8的余数，左移 3 位等价于乘以 8）。 将输入字节 buf[u] 左移到正确位置，并与 A 数组的对应位置进行异或。 flip函数则比较简单，其作用是应用 SHAKE 算法的填充规则（Padding），标记输入结束。 这一步的内部函数不太适合并行化，好在4个Shake示例彼此无关，所以在调用的时候可以并行操作。"},{"title":"签名部分优化-GAUSS-02","date":"2025-02-27T11:08:12.000Z","url":"/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-GAUSS-02/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"函数核心逻辑 高斯采样背景： 在基于格的密码学中，高斯采样用于生成签名噪声，确保安全性。 函数生成的值 x 符合均值为 t/2、标准差为 sigma_sign 的高斯分布，实际输出为 2*x（避免浮点运算）。 核心逻辑： 使用预计算的表 tab_hi 和 tab_lo 加速采样，表中存储离散高斯分布的累积概率分布。 通过随机数决定符号和绝对值，根据奇偶校验位 t 选择不同列，调整采样结果以满足特定约束。 随机数生成： sig_gauss 使用 SHAKE 哈希（基于种子生成伪随机流）。 sig_gauss_alt 直接调用外部 RNG，减少哈希计算开销。 逐行解析1. sig_gauss 函数 2. sig_gauss_alt 函数 与 sig_gauss 类似，但直接调用 RNG 生成 160 字节数据块，而非使用 SHAKE： 关键点总结 表驱动采样： 使用预计算的 tab_hi 和 tab_lo 加速高斯采样，通过查表减少实时计算量。 奇偶校验位处理： 根据 t 中的位选择不同的列，调整采样结果以满足签名中的线性约束。 符号处理： 符号位单独处理，通过位操作高效应用符号到绝对值结果。 随机数生成差异： sig_gauss 使用基于 SHAKE 的确定性随机数生成，适合需要确定性的场景。 sig_gauss_alt 直接使用外部 RNG，减少计算开销，适合资源受限环境。 性能优化： 通过循环展开（处理 4 个样本&#x2F;块）、位操作和查表优化性能。 代码行 解析 static uint32_t sig_gauss(...) 定义静态函数，返回 uint32_t 类型，用于计算签名的高斯采样结果。 const uint16_t *tab_hi; 声明指向高斯分布高位概率表的指针。 const uint64_t *tab_lo; 声明指向高斯分布低位概率表的指针。 size_t hi_len, lo_len; 声明表长度变量，分别表示高位和低位表的长度。 switch (logn) &#123; ... &#125; 根据 logn 选择不同参数（256&#x2F;512&#x2F;1024），设置对应的表和长度。 size_t n = (size_t)1 &lt;&lt; logn; 计算多项式环的维度 n = 2^logn。 uint8_t seed[41]; 声明41字节的种子数组，用于初始化随机数生成器。 rng(rng_context, seed, 40); 调用外部随机数生成函数填充种子（前40字节）。 uint32_t sn = 0; 初始化 sn 为0，用于累加所有采样值的平方和。 for (size_t j = 0; j &lt; 4; j ++) 循环4次，处理4个并行的SHAKE实例。 shake_context sc; 声明SHAKE上下文结构体，用于生成随机数流。 seed[40] = (uint8_t)j; 设置种子第41字节为循环索引 j，区分不同实例。 shake_inject(&amp;sc, seed, 41); 将种子注入SHAKE上下文，初始化哈希状态。 shake_flip(&amp;sc); 切换SHAKE到输出模式（”flipping” 阶段）。 for (size_t u = 0; u &lt; (n &lt;&lt; 1); u += 16) 循环生成 2n 个样本，每次处理16个样本的块。 union &#123; ... &#125; buf; 声明联合体 buf，用于存储SHAKE输出的40字节数据。 shake_extract(&amp;sc, buf.b, 40); 从SHAKE中提取40字节到 buf。 for (size_t k = 0; k &lt; 4; k ++) 处理每个块内的4个样本（共16个样本&#x2F;块）。 size_t v = u + (j &lt;&lt; 2) + k; 计算当前样本的全局索引 v。 uint64_t lo = dec64le(buf.b + (k &lt;&lt; 3)); 从 buf 中提取小端序的64位低位随机数。 uint32_t hi = dec16le(buf.b + 32 + (k &lt;&lt; 1)); 从 buf 中提取小端序的16位高位随机数。 uint32_t neg = -(uint32_t)(lo &gt;&gt; 63); 提取符号位，neg 为全0或全1的掩码。 lo &amp;= 0x7FFFFFFFFFFFFFFF; 清除 lo 的最高位（符号位）。 hi &amp;= 0x7FFF; 清除 hi 的最高位（符号位）。 uint32_t pbit = (t[v &gt;&gt; 3] &gt;&gt; (v &amp; 7)) &amp; 1; 从 t 数组中提取对应位，决定奇偶列。 uint64_t p_odd = -(uint64_t)pbit; 将 pbit 转换为全0或全1的64位掩码。 uint32_t p_oddw = (uint32_t)p_odd; 同上，但为32位掩码。 uint32_t r = 0; 初始化采样值 r 为0。 for (size_t i = 0; i &lt; hi_len; i += 2) 遍历高位表项，比较随机数与表值，计算 r。 uint64_t tlo = tlo0 ^ (p_odd &amp; (tlo0 ^ tlo1)); 根据奇偶列选择表项（异或操作）。 uint32_t cc = (uint32_t)((lo - tlo) &gt;&gt; 63); 若 lo &lt; tlo，则 cc=1，否则 cc=0。 r += (hi - thi - cc) &gt;&gt; 31; 若 hi &lt; thi + cc，则 r += 1。 uint32_t hinz = (hi - 1) &gt;&gt; 31; 若 hi == 0，则 hinz=0xFFFFFFFF，否则 0。 for (size_t i = hi_len; i &lt; lo_len; i += 2) 遍历剩余低位表项，补充计算 r。 r = (r &lt;&lt; 1) - p_oddw; 将 r 乘以2并应用奇偶性。 r = (r ^ neg) - neg; 应用符号位，若 neg 非零则取反。 x[v] = (int8_t)*(int32_t *)&amp;r; 将 r 转换为 int8_t 存入 x 数组。 sn += r * r; 累加 r^2 到 sn，用于后续范数计算。 变量含义表 变量名 类型 含义 logn unsigned 多项式环维度的对数（n = 2^logn）。 rng 函数指针 外部随机数生成函数。 rng_context void * 随机数生成器的上下文指针。 sc_extra shake_context * 预先生成的SHAKE上下文（可选）。 x int8_t * 存储高斯采样结果的数组。 t const uint8_t * 输入数据，决定奇偶列的位数组。 tab_hi const uint16_t * 高斯分布高位概率表。 tab_lo const uint64_t * 高斯分布低位概率表。 hi_len size_t 高位概率表的长度。 lo_len size_t 低位概率表的长度。 n size_t 多项式环维度 n = 2^logn。 seed uint8_t[41] 随机种子（40字节 + 1字节索引）。 sn uint32_t 所有采样值的平方和。 j size_t 循环索引（0-3），对应4个SHAKE实例。 sc shake_context SHAKE-256的哈希上下文。 u size_t 外层循环索引，处理样本块（步长16）。 buf 联合体 存储SHAKE输出的40字节数据。 k size_t 内层循环索引（0-3），处理每个块的4个样本。 v size_t 当前样本的全局索引（范围：0 到 2n-1）。 lo uint64_t 64位低位随机数（符号位已清除）。 hi uint32_t 16位高位随机数（符号位已清除）。 neg uint32_t 符号位掩码（0或0xFFFFFFFF）。 pbit uint32_t 奇偶列选择位（0或1）。 p_odd uint64_t 奇偶列的64位掩码。 p_oddw uint32_t 奇偶列的32位掩码。 i size_t 查表时的循环索引。 tlo0, tlo1 uint64_t 低位表中的相邻表项。 tlo uint64_t 根据奇偶列选择的低位表项。 thi0, thi1 uint32_t 高位表中的相邻表项。 thi uint32_t 根据奇偶列选择的高位表项。 cc uint32_t 比较标志（lo &lt; tlo 时为1）。 hinz uint32_t 高位随机数是否为0的掩码。 r uint32_t 最终的高斯采样值（转换为有符号数）。 "},{"title":"签名部分优化-GAUSS-01","date":"2025-02-27T11:08:08.000Z","url":"/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-GAUSS-01/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"低字节提取这个文件中也有 extract_lowbit 函数，我们按照之前的优化函数将其覆盖 高斯分布经过分析源代码和阅读代码中留下的注释，我们发现 sig_gauss 函数也是可以被优化的。 源代码原理 大致分析，该函数用于生成符合高斯分布的整数数组 x，并根据奇偶校验位 t 调整分布。其核心步骤如下： 初始化参数：根据 logn 选择预定义的查找表 tab_hi 和 tab_lo。 随机数生成：使用 SHAKE 实例或外部 RNG 生成随机数，提取低 64 位 (lo) 和高 16 位 (hi)。 符号与奇偶处理：根据 lo 的最高位确定符号，根据 t 的奇偶性选择查表列。 查表与累加：遍历查找表，计算样本值 r，并累加平方和 sn。 结果调整：应用符号和奇偶调整，存储到 x 数组。 优化方案设计该函数最大的优化点应该在于通过 AVX2 向量化，可同时处理四个样本，显著减少循环次数。 首先，考虑sig_gauss中的主循环结构。每个j对应一个SHAKE实例，处理u的块。每个块生成40字节的buf，然后处理四个k的样本。每个样本的lo和hi来自不同的位置。例如，在sig_gauss中，每次处理四个样本（k循环），每个样本需要处理lo和hi。 在AVX2优化中，可能希望同时处理四个样本的数据。例如，将四个样本的lo和hi分别加载到向量寄存器中，然后并行处理它们的计算过程。 例如，处理四个样本的lo值可以组成一个256位的向量（四个64位整数），hi值可以是四个16位的整数，可能需要扩展到32位或64位以适应向量寄存器。不过AVX2对64位整数的操作支持有限，可能需要更多的技巧。 另一个可能的优化点是查表部分。在循环中，对于每个i，从tab_lo和tab_hi中取出两个值，根据p_odd选择tlo0或tlo1，thi0或thi1。这部分可以转换为向量化的选择操作。例如，使用向量比较和混合指令来同时处理多个i值的条件选择。 不过，循环中的hi_len和lo_len可能较大，如果这些表是预先确定的，可以考虑将它们的结构重组为向量友好的形式，或者将循环展开，使得多个i的迭代可以并行处理。 此外，在计算r的累加时，原代码使用标量变量，可能需要转换为向量累加器，每个向量通道对应一个样本的r值。这样，在每次循环迭代中，可以同时更新四个样本的r值。 可能的优化步骤： 向量化SHAKE实例的处理：如果四个SHAKE实例可以并行执行，那么可以使用AVX2来加速SHAKE的内部处理，例如同时计算四个不同的块。但SHAKE的内部结构可能不容易向量化，这需要具体分析。例如，SHAKE使用的是Keccak算法，其内部状态是1600位，可能难以向量化。但原注释提到，四个实例可以并行处理，例如通过四个独立的上下文，在AVX2中可能用向量寄存器的不同通道处理不同的上下文。这可能需要手动展开循环，将四个SHAKE的状态存储在向量化的结构中，并使用AVX2指令同时处理四个不同的数据块。这可能比较复杂，但或许可行。 向量化样本处理：在处理每个u块中的四个k样本时，可以将四个样本的数据（如lo、hi、pbit等）打包到AVX2向量中，并行处理。例如，同时处理四个样本的查表、条件判断、符号应用等操作。这需要将标量操作转换为向量操作，并处理数据依赖。 例如，在计算r时，四个样本的r可以分别存储在向量的四个通道中，每个通道对应一个样本的累加。这样，循环中的查表操作可以向量化，同时对四个样本的数据进行处理。 处理奇偶位和符号位：每个样本的pbit和符号位可以通过位操作转换为向量掩码，然后用向量逻辑指令进行处理。例如，计算p_odd向量，然后用向量异或和与操作来选择表中的值。 查表的向量化：查表操作可能比较困难，因为每个样本的i循环需要访问不同的表项。但或许可以将表的数据结构重新排列，以便使用向量加载指令一次加载多个表项，然后用向量比较和混合指令来选择合适的值。 例如，假设tab_lo中的每个i对应两个元素tlo0和tlo1，可以将这些元素预先存储为向量的形式，使得每次加载可以处理多个i的条目。例如，将tab_lo组织成两个数组，一个存储tlo0，另一个存储tlo1，然后用向量加载指令同时获取多个i的tlo0和tlo1，再根据p_odd向量选择对应的元素。 条件计算的向量化：在计算条件（如(lo - tlo) &gt;&gt;63）时，可以使用向量比较指令生成掩码，然后转换为相应的条件结果。例如，AVX2的vpcmpgtq可以比较两个64位整数向量，生成掩码，然后转换为相应的位。 累加的向量化：在计算r的累加时，可以将每个样本的r值保存在一个向量寄存器中，每次循环迭代更新这四个值。例如，将四个r值存储在__m256i变量中，每次处理多个i条目，将结果向量加到累加器中。 由上面的分析可以得知，这一过程还需要学习一些知识，今天暂时无法开展具体的优化工作。"},{"title":"签名部分优化-MUL-02","date":"2025-02-27T11:07:55.000Z","url":"/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-MUL-02/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"昨天完成了对 bp_mul_32的优化工作，今天的任务则是优化 bp_muladd_64 源代码分析 bp_muladd_64原始代码的实现步骤如下： 输入分解： 将输入的 a 和 b 各分为两个32位块：a0（低32位）、a1（高32位），b0（低32位）、b1（高32位）。 例如：a &#x3D; a0 | (a1 &lt;&lt; 32)，b &#x3D; b0 | (b1 &lt;&lt; 32)。 部分乘积计算： 计算四个部分积： c0 &#x3D; a0 * b0（低32位乘积） c1 &#x3D; a1 * b1（高32位乘积） c2 &#x3D; (a0 ^ a1) * (b0 ^ b1)（交叉项的乘积） 结果组合： 通过异或操作合并部分积： c0 和 c2 的低32位组合到结果的低64位。 c1 和 c2 的高32位组合到结果的高64位。 累加到目标数组： 将最终结果异或到目标数组 d 中。 优化方案经过昨天的工作，其实这里能做的工作已然不多，只能加速一下异或和乘法操作了。 其中最重要的是下面这两行。 这两行代码在实现上是对一个二进制多项式的特定部分进行更新。具体来说，它们对 d指向的内存区域的两个连续的64位二进制数进行操作。以下是详细的操作步骤： 读取现有数据: 使用 dec64le(d)从 d指向的内存位置读取一个64位的二进制数。 使用 dec64le(d + 8)从 d + 8指向的内存位置读取另一个64位的二进制数。 计算新值: 对于第一个64位数，计算其与 c0和 c2左移32位的结果的异或。 对于第二个64位数，计算其与 c1和 c2右移32位的结果的异或。 写回内存: 将计算得到的新值以小端序的形式编码回 d指向的内存位置。 将计算得到的另一个新值以小端序的形式编码回 d + 8指向的内存位置。 "},{"title":"签名部分优化-MUL-01","date":"2025-02-27T11:07:49.000Z","url":"/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-MUL-01/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"函数介绍在该部分代码中存在着两个乘法辅助函数，其计算也是可并行化的，分别是 bp_mul_32 和 bp_muladd_64 。 bp_mul_32 相对比较好理解，本质是一个先与掩码做与运算，再计算部分积的异或结果，最后再应用一次掩码的过程，而 bp_muladd_64 写的就比较难以理解了。 通过查询官方文档和上网搜索后，我们了解到：bp_muladd_64 用于计算两个 64位二进制多项式 的乘积，并将结果累加到目标数组 d 中。二进制多项式的乘法在密码学中常用于基于环的运算（如NTRU算法），其核心是通过 异或（XOR） 和 按位与（AND） 操作实现多项式系数的组合。 原始代码解析bp_muladd_64原始代码的实现步骤如下： 输入分解： 将输入的 a 和 b 各分为两个32位块：a0（低32位）、a1（高32位），b0（低32位）、b1（高32位）。 例如：a = a0 | (a1 &lt;&lt; 32)，b = b0 | (b1 &lt;&lt; 32)。 部分乘积计算： 计算四个部分积： c0 = a0 * b0（低32位乘积） c1 = a1 * b1（高32位乘积） c2 = (a0 ^ a1) * (b0 ^ b1)（交叉项的乘积） 结果组合： 通过异或操作合并部分积： c0 和 c2 的低32位组合到结果的低64位。 c1 和 c2 的高32位组合到结果的高64位。 累加到目标数组： 将最终结果异或到目标数组 d 中。 显然原始代码在不使用AVX2指令集的情况下也使用了一些优化技巧，但在使用AVX2指令集优化的情况下将舍弃这些技巧，因此不再赘述。 性能影响这里出现了两个函数 dec32le 和 enc64le ，在这里做一些介绍。 dec32le 函数通常用于将一个 32 位的整数从小端字节序（Little-Endian）转换为大端字节序（Big-Endian），或者反过来。在许多计算机系统中，数据是以小端字节序存储的，但在网络传输或其他特定协议中，可能需要使用大端字节序。因此，这种函数在处理不同系统之间的数据传输时非常有用。需要注意的是，dec32le 并不是标准C库中的函数，它可能是某个特定库或代码中的自定义函数，作用是进行32位整数的字节序转换。 enc64le 函数的作用是将一个 64 位的整数以小端字节序（Little-Endian）的形式编码到指定的内存地址中。小端字节序是指在内存中，最低有效字节（Least Significant Byte, LSB）存储在最低的地址，而最高有效字节（Most Significant Byte, MSB）存储在最高的地址。具体来说，enc64le 函数的参数通常包括一个指向目标内存地址的指针和一个 64 位的整数。函数会将这个 64 位整数按照小端字节序写入到指定的内存地址。 容易发现，dec32le和 enc64le 都是对内存的访问操作，而频繁的 dec32le 和 enc64le 操作可能引入内存访问延迟。 优化代码在第一份优化代码编写完后，我认为从逻辑上第一份代码并没有使用到AVX2可处理256位向量的优势，所以只能推迟 bp_muladd_64 的优化，今天只能完成 bp_mul_32 的优化工作。 关注一下原始代码的逻辑，在运算z0~z3时，其进行运算实质上可以概括为 因此我可以实现直接将扩展后的 x_vec和 y_vec先交换索引为1和3的两个64位整数相乘后再交换回来循环左移重复来完成这一部分的计算。这里我使用函数**_mm256_permute4x64_epi64** 来完成这一点。 _mm256_permute4x64_epi64 的第二个参数是一个 8 位的控制掩码（control mask），用于指定如何重排 4 个 64 位整数。 控制掩码 0b10010011 的二进制表示如下： 第 0 位和第 1 位：11，表示目标位置 0 使用源位置 3（即 D）。 第 2 位和第 3 位：00，表示目标位置 1 使用源位置 0（即 A）。 第 4 位和第 5 位：01，表示目标位置 2 使用源位置 1（即 B）。 第 6 位和第 7 位：10，表示目标位置 3 使用源位置 2（即 C）。 因此，0b10010011 将 [A, B, C, D] 重排为 [B, C, D, A]。 避免多余操作，我第一次使用控制掩码 0b01101100，以后每次使用控制掩码 0b10010011 即可。 接下来我直接将 x_vec和 y_vec相乘，然后内部进行异或，就能得到z0~z3。由于我们设计的__m256i变量中索引为1、3、5、7的32位整数总为0，所以可以直接使用 _mm256_mul_epu32 指令，它会将高位进位保留到我们预留的位置。 此外，为了实现__m256i变量的快速内部64位异或，我编写了一个辅助函数，实现内部的水平异或。 优化后文件存档hawk_sign.c"},{"title":"密钥生成部分优化","date":"2025-02-27T11:07:32.000Z","url":"/SeverusBlog/2025/02/27/%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"优化过程 extract_lowbit函数 代码作用：从8个连续 int8_t元素中提取每个元素的LSB（最低有效位），打包成一个字节。 优化思路： 使用 _mm256_loadu_si256一次加载32字节（处理4个输出字节）。 通过 _mm256_and_si256与掩码 0x01提取所有字节的LSB。 用 _mm256_movemask_epi8将LSB转换为位掩码，直接生成压缩后的字节。 encode_gr中的符号位提取 代码作用：提取16位整数符号位，每8个符号位压缩为一个字节。 优化思路： 加载8个 int16_t到 __m256i寄存器。 用 _mm256_srai_epi16(val, 15)将所有符号位移动到低位。 通过 _mm256_movemask_epi8生成掩码，直接得到压缩后的字节。 源代码解释1. extract_lowbit 函数功能extract_lowbit 函数的作用是从一个整数数组 f 中提取每个元素的最低有效位（LSB），并将这些位打包成一个字节数组 f2。每个字节包含 8 个元素的最低有效位。 参数 logn: 一个无符号整数，表示数组大小的对数（即数组大小为 2^logn）。 f2: 输出的字节数组，用于存储提取的最低有效位。 f: 输入的整数数组，类型为 int8_t，表示有符号 8 位整数。 实现细节 函数首先计算数组的大小 n = 2^logn。 然后，函数将输入的 f 数组视为 uint8_t 类型的数组 fu，以便逐字节处理。 函数通过一个循环，每次处理 8 个元素，将每个元素的最低有效位提取出来，并打包成一个字节。具体来说，每个字节的第 v 位（从 0 到 7）对应 f 数组中第 u + v 个元素的最低有效位。 最终，提取的位被存储在 f2 数组中。 示例假设 f 数组的前 8 个元素的最低有效位分别为 1, 0, 1, 0, 1, 0, 1, 0，那么 f2 的第一个字节将是 0b10101010（即 0xAA）。 2. encode_gr 函数功能encode_gr 函数实现了 Golomb-Rice 编码，用于将整数数组 a 编码为字节流。Golomb-Rice 编码是一种用于无损数据压缩的编码方法，特别适用于具有几何分布的数据。 参数 logn: 一个无符号整数，表示数组大小的对数（即数组大小为 2^logn）。 dst: 输出的字节数组，用于存储编码后的数据。 dst_len: 输出数组的最大长度。 a: 输入的整数数组，类型为 int16_t，表示有符号 16 位整数。 low: 一个整数，表示固定部分编码的位数。 num_ignored: 一个指向整数的指针，用于存储最后一个字节中被忽略的位数。 实现细节 函数首先计算数组的大小 n = 2^logn。 然后，函数检查输出数组的长度是否足够，如果不足则返回 0 表示失败。 编码过程分为三个部分： 符号位编码：将每个整数的符号位（最高位）提取出来，并打包成字节。每个字节包含 8 个整数的符号位。 固定部分编码：将每个整数的低 low 位提取出来，并打包成字节。这部分编码是固定长度的。 可变部分编码：将每个整数的高位部分（即除去低 low 位的部分）进行 Golomb-Rice 编码。这部分编码是可变长度的，使用一元编码表示整数的值。 最后，函数返回编码后的字节数。 示例假设 a 数组的前 8 个整数分别为 3, -2, 5, -7, 1, -4, 6, -8，low 为 2，那么： 符号位编码结果为 0b10101010（即 0xAA）。 固定部分编码结果为 0b11011101（即 0xDD）。 可变部分编码结果取决于整数的值，具体编码方式为一元编码。 返回值 如果编码成功，函数返回编码后的字节数。 如果编码失败（例如输出数组长度不足），函数返回 0。 源代码用到的一些技巧 size_t n = (size_t)1 &lt;&lt; logn 通过移位操作计算数组大小，仅在数组大小一定为2的幂时有效，可减少计算量。 fu[u + 0] &amp; 1u 1u 是 C 语言中的一个常量表达式，表示一个无符号整数（unsigned int）的值为 1。这里的 u 后缀表示这是一个无符号整数（unsigned）。 f2[u &gt;&gt; 3] 相当于 u/8，因为u的步长是8。 "},{"title":"签名部分优化-XOR","date":"2025-02-27T11:07:11.000Z","url":"/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-XOR/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"],["Hawk","/SeverusBlog/tags/Hawk/"]],"categories":[[" ",""]],"content":"头文件特殊解析在官方提供的AVX2优化方案中，头文件 hawk_inner.h 中多出了下面这一段。 这段代码可以作如下解释 #include &lt;immintrin.h&gt;：这是Intel提供的头文件，包含了AVX2和其他SIMD指令集的内联函数定义。 #if defined __GNUC__ || defined __clang__：这是一个条件编译指令，检查编译器是否是GCC（GNU Compiler Collection）或Clang。 如果是GCC或Clang，则包含 &lt;x86intrin.h&gt;头文件，该头文件提供了x86架构特有的内联函数支持。 HAWK_LE：如果未定义，则定义为1。可能用于指示代码是小端（Little Endian）模式。 HAWK_UNALIGNED：如果未定义，则定义为1。可能用于指示是否支持非对齐内存访问（unaligned memory access）。 GCC或Clang： TARGET_AVX2：定义一个属性 __attribute__((target(&quot;avx2,bmi,pclmul&quot;)))，指示编译器生成的代码需要支持AVX2、BMI（Bit Manipulation Instructions）和PCLMUL（Carry-Less Multiplication）指令集。 TARGET_AVX2_ONLY：定义一个属性 __attribute__((target(&quot;avx2&quot;)))，指示编译器生成的代码只需要支持AVX2指令集。 ALIGNED_AVX2：定义一个属性 __attribute__((aligned(32)))，指示数据需要32字节对齐（AVX2指令集通常要求数据对齐）。 MSVC（Microsoft Visual C++）： #pragma warning( disable : 4752 )：禁用警告4752。该警告通常与浮点优化相关，禁用它是为了避免编译器在优化AVX2代码时产生不必要的警告。 所以我们可以看到，在官方提供的AVX2优化方案中，有一部分函数前加上了如 TARGET_AVX2 的属性，这一点在之后的优化需要加以注意。 XOR函数优化虽然我现在还不完全能看明白签名部分的算法原理，但这并不影响找到一些可优化点。很容易发现，在代码中存在着 bp_xor_64 、bp_xor_128 、bp_xor_256 、bp_xor_512 、bp_xor_1024 这一类异或函数，其中的计算都是可并行化的，符合使用AVX2优化的要求。 这里的 #if HAWK_UNALIGNED 实际上是一种降低可执行文件大小的方法，意为如果 HAWK_UNALIGNED 为1，则编译这一段代码，否则直接编译另一段代码，也是一种节约内存和文件大小的技巧，因此，在优化方案中也要同时设计对齐和非对齐的处理方案。 而优化这一段代码的方案也比较简单，所需要做的只是使用AVX2指令从内存中加载，然后使用AVX2的异或指令即可。而且因为异或操作并不涉及进位，所以在512位前直接加载即可，不需要设计数组。 "},{"title":"AVX2移位","date":"2025-02-27T11:06:14.000Z","url":"/SeverusBlog/2025/02/27/AVX2%E7%A7%BB%E4%BD%8D/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"]],"categories":[[" ",""]],"content":"AVX2移位实践过程 练习记录 日期：2025&#x2F;1&#x2F;22 练习内容：编写一个使用AVX2指令集优化的移位算法 遇到的问题：无 解决方案：无 代码： "},{"title":"AVX2矩阵乘法","date":"2025-02-27T11:05:25.000Z","url":"/SeverusBlog/2025/02/27/AVX2%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"]],"categories":[[" ",""]],"content":"AVX2矩阵乘法实践过程 练习记录 日期：2025&#x2F;1&#x2F;21 练习内容：编写一个使用AVX2指令集优化的矩阵乘法算法 遇到的问题：当矩阵列数不为步长的倍数时，可能发生计算错误或溢出错误 解决方案：将矩阵列数补全为步长的倍数 代码： "},{"title":"AVX2加法","date":"2025-02-27T11:03:48.000Z","url":"/SeverusBlog/2025/02/27/AVX2%E5%8A%A0%E6%B3%95/","tags":[["AVX2","/SeverusBlog/tags/AVX2/"]],"categories":[[" ",""]],"content":"AVX2加法使用AVX2指令集的指令优化一个最简单的程序 实践过程 练习记录 日期：2025&#x2F;1&#x2F;20 练习内容：编写一个简单的实现数组相加的程序并使用AVX2优化。 遇到的问题：编译无法通过。 解决方案：添加 -mavx2 编译选项 代码： "},{"title":"记一次面试之回溯法求解数组分割问题","date":"2024-11-21T08:11:16.000Z","url":"/SeverusBlog/2024/11/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%B1%82%E8%A7%A3%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98/","tags":[["-面试题","/SeverusBlog/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"categories":[[" ",""]],"content":"今天进行了一次技术面试，前面还能和面试官聊的比较好，直到我错了一个C的基础知识，感觉有点紧张，面试官让我屏幕共享做一道算法题，由于之前没有共享屏幕做题的经历，紧张感更强了，有点担心写不完题目，知道要用回溯法，但是一时之间没法组织出具体的代码。好在面试官让我展示了博客，允许我之后在博客上补全这个题目的结果，于是现在就来把这个题做完。 静态变量的存储位置和计算在做题之前，先记录一下回答错的C的知识，简单来说就是在函数内部静态定义了一个变量，之后再调用这个函数的时候，每次对这个变量自加并打印，会显示什么，我当时以为每次定义变量时都会重写变量，所以回答每次的结果都是一样的，后来面试官让我现场实验我才发现我错了，每次输出的数据都会自增，现在我来记录一下原因。 C语言中，如果在函数内部使用 static关键字定义一个变量，例如 static int a = 0;，这个变量会具有以下特点： 静态存储周期 ：变量 a的生命周期是整个程序运行期间，即使函数返回，变量 a的值也不会被销毁，而是保留原来的值。 局部作用域 ：变量 a的作用域依然是函数内部，不能在函数外部直接访问。 如以下的函数： 连续调用三次，其输出结果会是 这里需要说明一下，在C语言中，静态变量存储在 静态存储区 （也称为 全局数据区 ），具体细分为以下两部分： 数据段（Data Segment） 如果静态变量有显式初始化（如 static int a = 0;），它会存储在 已初始化的静态存储区 。 初始化值在程序加载时被写入对应的内存区域，程序运行时直接使用。 BSS段（Block Started by Symbol） 如果静态变量没有显式初始化（如 static int b;），它会存储在 未初始化的静态存储区 。 静态变量默认初始化为 零 ，即在程序加载时，该区域的所有字节会被清零。 所以我们的静态局部变量被存储在数据段中，而且初始化指令只会执行一次，这就是为什么 a会自增而不是永远输出1。 逐步分析： 第一次调用函数时： 静态变量 a被初始化为 0（仅在程序执行到此处第一次调用时初始化一次）。 执行 a++，a变为 1。 打印 a的值，输出 1。 第二次调用函数时： 变量 a已经存在，并且值为上次调用后的 1。 执行 a++，a变为 2。 打印 a的值，输出 2。 第三次调用函数时： 变量 a的值为上次调用后的 2。 执行 a++，a变为 3。 打印 a的值，输出 3。 回溯法求解数组分割问题问题很简单，给一个数组 a[]，要求将其分割为两个和值相等的数组 b[]和 c[]。 这个问题是回溯法的经典运用，首先我们可以确定数组a[]的和值必须是偶数，不然一定没有答案。然后我们将 a[]的和除以二，就可以得到需要达到的数组和 target，只要能够找到一组符合要求的数组，那剩下的元素必然和值为 target，如果不是 target，说明条件是不成立的。这里我们要递归地寻找元素，然而每次递归之后都要恢复现场，这就是回溯法。 由于当时虽然想到使用回溯法，但脑子实在有点太紧张，以至于写的很慢而且没想清楚具体的代码结构，所以最后也只写了个大体的递归结构出来，被面试官叫停了，希望面试官能看到接下来我完善后的代码。 需要说明的是，由于最后的拆分步骤需要识别哪些元素已经被加入到 b中从而将剩余元素构建成 c，使用一个布尔类型数组 used来识别哪些元素是b使用的，这一数组也需要进行回溯。 代码及注释如下，这份代码命名比较抽象，可读性比较差，可以看后面规范化后的代码： 上面代码函数和变量命名略显抽象，因为我想思路的时候命名都比较随意，重新规范化命名函数和变量如下，可读性应该会好一点： 运行结果如下： 输入序列为 &#123;1, 5, 11, 5, 0&#125; 输入序列为 &#123;1，2&#125; 输入序列为 &#123;1，4，7，10&#125; 输入序列为 &#123;7, 47, 42, 15, 14, 10, 69, 96, 33, 69, 23, 6, 29, 33, 80, 32, 72, 34, 53, 24, 76, 66, 14, 76, 15, 14, 27, 89, 89, 65, 32, 57, 52, 20, 70, 77, 8, 59, 3, 8, 39, 17, 94, 9, 96, 36, 59, 61, 97, 49, 88, 4, 47, 87, 86, 17, 60, 30, 13, 68, 27, 24, 93, 83, 91, 33, 64, 98, 24, 12, 28, 10, 27, 93, 59, 17, 37, 44, 45, 57, 50, 67, 89, 94, 90, 86, 98, 56, 25, 39, 52, 87, 62, 49, 31, 61, 55, 4, 25, 26&#125; 输入序列为 &#123;1，2，8，99&#125; 结果输出均正确，这个问题也顺利解决了。 "},{"title":"LeetCode 2398: 预算内的最多机器人数目","date":"2024-09-12T18:15:19.000Z","url":"/SeverusBlog/2024/09/13/LeetCode-2398-%E9%A2%84%E7%AE%97%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%95%B0%E7%9B%AE/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"虽然刚学Java不久，但也不能天天做简单题，今天正好每日一题是一道困难题，就来做做看。 题目你有 n 个机器人，给你两个下标从 0 开始的整数数组 chargeTimes 和 runningCosts ，两者长度都为 n 。第 i 个机器人充电时间为 chargeTimes[i] 单位时间，花费 runningCosts[i] 单位时间运行。再给你一个整数 budget 。 运行 k 个机器人 总开销 是 max(chargeTimes) + k * sum(runningCosts) ，其中 max(chargeTimes) 是这 k 个机器人中最大充电时间，sum(runningCosts) 是这 k 个机器人的运行时间之和。 请你返回在 不超过 budget 的前提下，你 最多 可以 连续 运行的机器人数目为多少。 示例 1： 解释：可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 sum(2,1,3) &#x3D; 6 + 3 6 &#x3D; 24 ，小于 25 。可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。 示例 2： 提示： chargeTimes.length == runningCosts.length == n 1 &lt;= n &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt; 1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt; 1 &lt;= budget &lt;= 10&lt;sup&gt;15&lt;/sup&gt; 滑动窗口其实这个题目中比较关键的是连续这两个字，因为其实充电时间和运行时间什么的都只是需要计算的数据，而连续这两个字就代表了我们不能直接排序，而是要使用滑动窗口的方法。滑动窗口在思想上的表现就是一种子视图，通过动态控制这个视图的大小来截取数据，单次遍历即可实现。窗口左侧只能删除数据而右侧只能添加数据。窗口永远不会向左移动。在这个题目中我们删除或添加数据的方法就是计算总预算的值。运行时间的和是比较好计算的，但是最大充电时间这个值每次都要重新计算，会消耗大量计算时间，当然也有优化的办法，那就是使用双端队列来维护这个充电时间，用空间换时间，不过这个可以之后再讲，我们先拿出一份朴素的、超时的代码。 这份代码有多朴素呢，首先它能通过数据量比较小的测试用例，说明它的思想是对的，但是这里的滑动窗口没有用双指针来实现（偷懒ing🤗），然后每次都重算一遍最大充电时间和总运行时间，哪怕根本不用双端队列，也可以把总运行时间的运算抽离成每次循环只计算一次，但是我没有。所以总的来说，这份代码写的比较粗犷，自然而然也就超时了，不过相应的，也比较好读懂。放这份代码是为了介绍接下来双端队列的内容，方便看懂。 双端队列由于双端队列完全在这个滑动窗口中工作，所以介绍一下使用双指针实现的滑动窗口。 滑动窗口的双指针实现滑动窗口是一种通过一对指针（通常称为 left和 right）来动态调整子数组范围的技术。在遍历数组的过程中，右边界 right每次右移（扩大窗口），当某些条件满足（如总费用超过预算）时，左边界 left右移（缩小窗口）。滑动窗口能够在O(n)时间内遍历整个数组，并动态调整窗口的范围，从而避免嵌套循环。 在这个问题中，窗口表示当前可以操作的机器的范围： right 指针表示当前处理的机器。 left 指针表示窗口的左边界。 每次 right指针右移时，我们会计算当前窗口内的总费用，若费用超过预算，就移动 left指针缩小窗口。通过这种方式，我们可以在O(n)时间内找到最大数量的机器。 双端队列的介绍双端队列是一种可以在两端高效插入和删除元素的数据结构。这里我们使用它来维护滑动窗口内的最大值，这样我们可以在O(1)时间内获取窗口中的最大充电时间。 这个问题中，我们希望能够动态地得到当前窗口中机器的最大充电时间。如果使用上面的代码那样计算最大值，时间复杂度会很高。所以我们使用双端队列来保存数组的索引，并维护一个“递减队列”： 队列的左端 ：存储当前窗口中最大充电时间的索引。 队列的右端 ：存储接下来可能成为最大值的元素的索引。 简单来说，队列的最左端的索引值所在的位置一定在当前窗口中，如果left大于该索引值，队列就会删掉这个元素，从而使得下一个元素成为最大值。而每次right移动时都会加入一个新的索引到这个队列中，如果这个索引值对应的最大充电时间大于其左边的一些值，那么直接把这些值全部从队列中删掉。因为这些值都没有必要判断了，在一个只会右移的窗口中它们不再具有意义。 如何使用双端队列 当 right指针右移时，比较 chargeTimes[right]和双端队列的末尾。如果 chargeTimes[right]大于或等于队列末尾的元素，那么队列末尾元素就没用了，因为它永远不会成为窗口中的最大值。因此，移除队列末尾的元素，直到队列末尾的元素比 chargeTimes[right]大。 把 right对应的索引加入队列末尾。 如果滑动窗口的左边界（即 left）超出了队列中存储的最大值的范围（即 deque.peekFirst()），则移除队列的左端（也就是最大值）。 通过这个方法，队列的左端始终保存当前窗口中的最大值的索引，因此可以快速获取最大值。 每次 right指针右移时的操作实际上根据上面的原理可以写出来，每次 right指针的右移会有如下操作： 更新双端队列 ：将 chargeTimes[right]加入队列，确保队列中始终保持当前窗口的最大充电时间在队首。 更新窗口总运行费用 ：累加 runningCosts[right]到总费用中。 判断窗口总费用是否超过预算 ：如果超出预算，通过移动 left指针来缩小窗口，并相应地更新总运行费用和双端队列。 计算最大窗口大小 ：更新最大能操作的机器数量。 源码综上能得到下面这份源码： 虽然没达到100%，仍有进步空间，但感觉也不错了。"},{"title":"LeetCode 94: 二叉树的中序遍历","date":"2024-09-11T13:00:24.000Z","url":"/SeverusBlog/2024/09/11/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"题目给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 示例 2： 示例 3： 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 中序遍历的概念就当作是数据结构的复习了，稍微回顾一下中序遍历顺序的结构。简单来说三种遍历顺序都用递归算法来实现的话，就是访问根节点的时机。 中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则： （1）中序遍历左子树 （2）访问根结点 （3）中序遍历右子树 思路简单来说就是递归访问，按中序遍历的顺序先左再根最后右。如果要用迭代算法就引入一个栈的数据结构。 这里注意一下List的方法，java里 list没有 append和 insert方法，使用 add方法和addAll方法即可。 题解"},{"title":"LeetCode 82&83: 删除排序链表中的重复元素","date":"2024-09-11T10:54:53.000Z","url":"/SeverusBlog/2024/09/11/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"题目83给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例 1： 示例 2： 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 思路由于链表已经排好序了，检查下一个节点的数值并和当前节点比较应该就能解决这个问题吧。 题解就是基础的检查元素并删除节点的操作。 题目82为什么要先做83呢，因为83难度是简单但82是中等。 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例 1： 示例 2： 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 尝试思路什么的先放一边，我们把刚刚写的源码放进去再执行一遍，看看这题有什么不同。 原来这道题要把重复的节点全部删掉，这样就比刚刚复杂了。 思路就在此时我浮现了一个思路，既然是单向升序链表，也就是说，只要我设置把重复的节点val设成head的val-1或者-101，然后等全部执行完再遍历一遍删除，应该就能实现这个功能了。 理论存在，实践开始！ 题解首先引入一个标志 flag，这个标志负责记录当前节点有没有重复的下一节点，如果有则置1，等待该节点完成一般的删除重复节点操作后，在其即将进入下一个不重复的节点时修改当前节点的值为-101，然后再复位。当执行完一般的删除重复节点操作后，再从头指针开始遍历，遇到节点值为-101的情况就删除当前节点。需要注意的是，如果头节点的值为-101，则要执行特殊的删除循环结构，因为头节点没有前驱。同时注意一下null的情况，就可以完成这个题目了。 "},{"title":"LeetCode 67: 二进制求和","date":"2024-09-10T11:06:19.000Z","url":"/SeverusBlog/2024/09/10/LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"最近在学Java，所以重新刷一点LeetCode的简单题，尝试用Java来实现。 题目给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 示例 1： 示例 2： 提示： 1 &lt;= a.length, b.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; a 和 b 仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成 字符串如果不是 &quot;0&quot; ，就不含前导零 初步思路很显然，初步的思路有把字符串转换成整型进行加法后再转换成字符串和直接在字符串内从后向前遍历并设置进位器进行异或运算两种。从原理上后者似乎更接近硬件实现，但我们两种都可以尝试一下。 思路一源码 这份源码很好懂，总之就是先把字符串变成整数加算后再变回去，变回去的时候用的是递归运算。这份代码还有很大的优化空间，但是没什么必要，因为没通过测试用例。 原因很简单，我发现我看错了题目，是长度小于10000而不是数值小于10000…… 话不多说，直接进思路二。 思路二这个思路就是要求我们从后往前遍历字符串进行累加，倒也不算困难。 主要方法是建立一个含有进位存储器的异或方法，有点像寄存器，然后就可以用循环结构计算了。 在编写的过程中了解到 StringBuilder类中还有一个 Reverse()方法，可以直接逆序，很方便。 源码： 然而这份代码也是有问题的，他进位时会发生错误，无奈只能创建一个主类来进行调试了。 测试时发现，第一步计算 symbol时没有出现问题： 原因出在这里，第二次计算symbol时，又把进位值重置成0了，这就导致进位不生效。 由于三个个位二进制数加和永远不可能大于四，所以这里我们可以作如下修改： 本地测试一下，能进位了： 直接在LeetCode上提交，然后又错了： 又调试了一遍，还是这个进位的问题，忽视了进位与原数再产生进位的情况。 修改如下： 因为实际上三个数相加最多产生一次进位，为了不忽视两次运算的进位情况，将两次进位值异或即可。 再次提交就通过了。 时间复杂度和空间复杂度都是O(n)，显然不是最佳解法，看了一下题解，较好的方案把每个字符化成整型然后加法再变回字符和进位。相当于是我的思路一与思路二的结合体，我这种可能更接近于硬件方案吧。最后稍微优化了一些结构，源码及注释如下： "},{"title":"网络安全网络侦察实验","date":"2024-09-09T19:27:28.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"使用nmap、ettercap进行网络侦查和密码嗅探使用nmap工具进行网络侦察在Kali linux操作系统中打开操作终端，并使用nmap命令扫描192.168.1.0网段的存活主机，并探测该网段存活主机的开放端口、服务、操作系统及版本信息。 获得三台主机的信息： 分别扫描出了其端口信息、操作系统和版本信息。 使用ettercap工具进行密码嗅探使用嗅探工具对目标机的vsftpd服务进行嗅探。通过设置监听网卡、主机、开启arp欺骗、启动嗅探等步骤来嗅探网络内的数据包，获取ftp用户名和密码 在kali系统中打开ettercap的图形界面： 设置嗅探网卡：eth0 有线网卡 选择工具栏 Hosts-Host lists，并且使用 Scan for hosts来找出指定网段内的所有存活主机，并将其加入目标： 检查ip_forward是否为1，若不为1则需修改。 开始攻击，攻击方法为 ARP Poisoning 得到ftp的密码：ftp123 使用crunch、hydra暴力破解ssh服务使用crunch工具生成密钥在操作机使用相关工具，要求从字符串“hacker +123456”中，随机选9个字符进行排列组合，生成密码字典文件password.txt。 使用hydra爆破ssh 得到密码hacker123 使用ssh登录目标机并获取key值，获得敏感信息 1.key中内容是ettercap。 获取目标网站的webshell权限，控制目标机，获得敏感信息在操作机创建脚本，建立一个上传表单；建立一个php文件，作为一句话木马。通过上传表单上传一句话。 该网站网址是  我们选择这样的一句话木马： 其意义为执行GET请求中cmd的参数 我们将这这个一句话木马保存到 webshell.php中。 在浏览器另外一个页面快速打开 ，获得时间戳，分析可知上传的文件名以时间戳+下划线+原文件名称来命名。 我们选择用python编写脚本 我们将脚本文件和一句话木马文件准备好： 执行脚本文件： 测试命令phpinfo() 出现该页面说明我们的一句话木马上传成功了。 添加用户： 添加管理员： 输入命令 tasklist -svc 找到COMSysApp svchost服务的PID为2416 然后输入 netstat -ano来查找COMSys svchost服务对应的端口号，即远程桌面端口 如图，远程桌面端口号为35155； 远程连接并查看文件内容 修改文件属性 文件内容是 ftpstandrd123"},{"title":"网络安全入侵检测实验","date":"2024-09-09T19:27:03.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"在不同的操作系统环境下安装和配置OSSEC代理，构建入侵检测环境在Windows平台下安装和配置OSSEC代理安装OSSEC HIDS Windows Agent工具软件文件位置： C:/tools 目录下 设置OSSEC服务器IP 密钥由服务器生成 使用putty远程登录OSSIM服务器登陆设置： 登陆成功界面： 启动OSSEC代理管理程序找到位置：/var/ossec/bin/manage_agents 启动服务： 添加代理： 用户名：windows2012 ID：005 生成密钥： 在OSSET AGENT管理器窗口Authentication key栏里输入生成的密钥并保存 启动新建的OSSEC代理，查看该代理成功运行后的运行状态信息 在Linux平台下安装和配置OSSEC代理切换到CentOS7虚拟机 SSH连接 新建一个OSSEC代理和上面步骤相同，但是把代理名修改为CentOS7和把ID改为006。 查看密钥： 回到CentOS7，启动该系统上的manage_agents服务，然后输入密钥建立连接： 查看配置文件 发现没有对应配置，手动添加： 保存退出。 重启OSSEC服务重启方法为 查看代理状态 如图所示，CentOS7的代理服务已激活。 监视OSSIM服务器本地root用户的登录情况访问OSSIM集成监测平台网址：  查看配置信息在Analysis—&gt;Detection—&gt;HIDS—&gt;Config—&gt;Ossec.conf，可以看到OSSIM集成检测平台已经默认监视了日志文件&#x2F;var&#x2F;log&#x2F;auth.log 图形界面和命令行切换登录切换到alienvault用户，使用命令 ./ossec-control restart重启OSSIM服务器 这里需要使用VNC连接到192.168.1.200的主机上： 然后使用Crtl+Alt+F1进入界面并登录： 进入后再退出 然后在使用Crtl+Alt+F7组合键回到图形模式： 在windows2012上远程连接到服务器192.168.1.200前一个任务中已完成 查找日志在windows2012的OSSIM Web页面上，单击Analysis—&gt; Security Events (SIEM)，可以看到，Security Events页面中列出了OSSIM系统预设检测规则适用范围内的所有安全事件日志信息，可以找到通过putty远程登录时相关的SSH登录记录报警信息。该日志信息可作为系统管理员判断本次远程登录是否为非法入侵的重要报警信息。如果OSSIM服务器不允许root用户的远程登录操作，那么root用户的本次远程登录操作将被视为黑客入侵行为 root用户远程登录成功后OSSIM监测到的SShd登录成功的报警日志的signature信息： 进行ossec报警数据过滤 基于SSH的远程非法入侵检测登录并查看检测规则文件 修改一条规则 重启命令：/var/ossec/bin/ossec-control restart 用任意错误密码尝试登陆先把root设置为非法用户： vim/etc/ssh/sshd_config 重启服务：service ssh restart 得到错误密码报警： 监视CentOS7 root用户情况在OSSIM集成检测平台上设置规则，监测CentOS7用户情况 重启ossec服务。 创建用户 查找报警信息 监控Web服务器的访问日志修改ossec.conf文件 重启 访问 显示Not Found 查看报警信息 "},{"title":"网络安全防火墙实验","date":"2024-09-09T19:26:46.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"Linux 防火墙 Iptables 基础防火墙一些概念从防火墙作用范围讲，防火墙可以大体分为主机防火墙和网络防火墙。 网络防火墙和主机防火墙在企业网络架构中所处的网络位置不一样，它俩的结合能使企业网络更安全。 从产品形态讲，防火墙可以分为硬件防火墙和软件防火墙。 下面说说本实验的重点，Linux iptables。 iptables 其实它并不是真正的防火墙，我们可以理解它为一个命令行工具，位于用户空间，我们用这个工具操作”安全框架”。netfilter 是防火墙真正的安全框架（framework），netfilter 位于内核空间。 netfilter&#x2F;iptables（下文中简称为 iptables）组成 Linux 平台下的包过滤防火墙，与大多数的 Linux 软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 Netfilter 是 Linux 操作系统内核的一个数据包处理模块，主要有如下功能： Iptables 基础 表的概念 链的概念 表和链的对应关系： 同一链在不同表中的执行优先级次序（由高而低）： Iptables 使用语法Centos7 下可用 firewalld 和 iptables 两种防火墙管理方式,实验中使用 iptables。 基本语法格式： 链管理： 规则管理： 保存规则： 恢复规则: 规则查看： 登陆实验机 登陆帐号：root，登陆密码：Simplexue123 Iptables 简单使用使用 man 手册 查看 filter 表规则, iptables 默认使用 filter 表 添加规则,允许所有网络访问本机 注意：在不指定源、目的地址,源、目的 IP,协议的情况下为全部 IP、端口、协议为 FORWARD 链添加默认规则 添加自定链 test 删除自定链 test Iptables 主机防火墙和审计常用语法对于任何协议及协议的扩展，通用匹配都可以直接使用。 （1）匹配指定协议。 -p，–protocol 例: iptables -A INPUT -p tcp -j ACCEPT 说明匹配指定的协议，指定协议的形式有以下几种： （2）以 IP 源地址匹配包。 -s，–src，–source 例: iptables -A INPUT -s 192.168.0.1 -j ACCEPT 说明以 IP 源地址匹配包。地址的形式如下： （3）以 IP 目的地址匹配包。 -d，–dst，–destination 例: iptables -A INPUT -d 192.168.0.1 -j ACCEPT 说明以 IP 目的地址匹配包。地址的形式和–source 完全一样。 （4）以包进入本地使用的网络接口匹配包。 -i例: iptables -A INPUT -i eth0 -j ACCEPT 说明以包进入本地所使用的网络接口来匹配包。要注意这个匹配操作只能用于 INPUT，FORWARD 和 PREROUTING 这三个链，用在其他任何地方会提示错误信息。指定接口有以下方法： （5）以包离开本地所使用的网络接口来匹配包。 -o例: iptables -A OUTPUT -o eth0 -j ACCEPT 说明以包离开本地所使用的网络接口来匹配包。要注意这个匹配操作只能用于 OUTPUT，FORWARD 和 POSTROUTING 这三个链，用在其他任何地方会提示错误信息。 （6）匹配通信源端口。 –source-port，–sport例: iptables -A INPUT -p tcp --sport 1111 说明当通信协议为 TCP 或 UDP 时，可以指定匹配的源端口，但必须与匹配协议相结合使用。 （7）匹配通信源端口。 – destination-port，–dport例: iptables -A INPUT -p tcp --dport 80 说明当通信协议为 TCP 或 UDP 时，可以指定匹配的目的端口，但必须与匹配协议相结合使用。 状态检测-m state –state {NEW,ESTATBLISHED,INVALID,RELATED},指定检测那种状态 （1）NEW:该包想要建立一个新的连接（重新连接或连接重定向）。 （2）RELATED:该包是属于某个已经建立的连接所建立的新连接。 （3）ESTABLISHED：该包属于某个已经建立的连接。 （4）INVALID:该包不匹配于任何连接，通常这些包被 DROP。 例: iptables -A INPUT -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT 特殊参数–icmp-type 指定 ICMP 的类型编号 例: iptables -A INPUT -p icmp --icmp-type 8 -m multiport 指定多端口号 –sport –dport –ports 例: iptables -A INPUT -p tcp -m multiport --dport 22,53,80,110 -m iprange 指定 IP 段 –src-range ip-ip –dst-range ip-ip 例: iptables -A INPUT -m iprange --src-range 192.168.1.2-192.168.1.7 -j DROP -m connlimit 连接限定 –comlimit-above # 限定大连接个数 例: iptables -A INPUT -p tcp --syn --dport 22 -m connlimit --connlimit-above 100 -j REJECT -m limit 现在连接速率，也就是限定匹配数据包的个数 –limit # 指定速率 –limit-burst # 峰值速率，最大限定 例: iptables -A INPUT -m limit --limit-burst 6 -m string 按字符串限定 –algo bm|kmp # 指定算法 bm 或 kmp –string “STRING” # 指定字符串本身 例: iptables -A OUTPUT -m string --string &quot;tudou.com&quot; --algo bm -j DROP iptables 常用的操作语法 功能 参数 语法 说明 添加规则 A iptables -A INPUT -p tcp -j ACCEPT 在 INPUT 链后加入允许所有 TCP 请求 删除规则 -D iptables -D INPUT -p tcp -j ACCEPT 在 INPUT 链中删除对应规则 自定义链重命名 -E iptables -E A B 将自定义链 A 重命名为 B，原来的名字在前，新名字在后 清空规则 -F iptables -F INPUT 清空 INPUT 链规则, 如果不加链名则是清除当前表所有规则 插入规则 -I iptables -I INPUT 1 -p tcp -j ACCEPT 在 INPUT 链内的某个位置插入规则，如果序号为 1 或没有序号，规则会被插入到的头部 显示规则 -L iptables -L INPUT 显示 INPUT 链的所有规则，如果没有指定链，则显示指定表中的所有链。精确输出可用-n 和-v 等参数 新建自定义链 -N iptables -N A 在指定表新建链 A,不可以同名 默认策略 -P iptables -P INPUT DROP 指定 INPUT 链的默认策略为 DROP, 可选策略 ACCEPT、DROP、REJECT、REDIRECT 替换规则 -R iptables -R INPUT 1 -p udp -j ACCETP 替换 INPUT 链中的第 1 条策略 删除用户自定义链 -X iptables -X A 删除指定表中的自定义链 A 计数器归零 -Z iptables -Z 清空指定表下指定链（如未指定则认为所有链）的所有计数器归零 iptables 日志记录Linux 下单独记录 Iptables 日志,编辑&#x2F;etc&#x2F;syslog.conf 文件，加入一行 重启 rsyslog 服务生效： 例: 记录源为 127.0.0.1 为来的所有 ICMP 日志 (1) 配置 iptables 策略 (2) 验证规则 图中 pkts 有两个数据包匹配 (3) 查看日志 (4) 上例 iptables 日志字段解释(编号 21 后为未用到的字段) 编号 字段 说明 1 Apr 27 20:28:57 日期时间，由 syslog 生成 2 localhost 主机名称 3 kernel syslogd 获取 kernel 产生的日志 4 iptables icmp-localhost 记录前缀，由用户指定—log-prefix “iptables icmp-localhost” 5 IN&#x3D;lo 数据包进入的接口，若为空表示本机产生 6 OUT&#x3D; 数据包流出的接口，若为空表示本机产生 7 MAC&#x3D;00:00:00:00:00:00:00:00:00:00:00:00:08:00 前 6 段为源 MAC, 后 6 段为目的 MAC 8 08:00 08:00 为上层协议代码，即表示 IP 协议 9 SRC&#x3D;127.0.0.1 源 IP 地址 10 DST&#x3D;127.0.0.1 目的 IP 地址 11 LEN&#x3D;84 IP 封包+承载数据的总长度(MTU) 12 TOS&#x3D;0x00 IP 包头内的服务类型字段，能反应服务质量包括延迟、可靠性和拥塞等 13 PREC&#x3D;0x00 服务类型的优先级字段 14 TTL&#x3D;64 IP 数据包的生存时间 15 ID&#x3D;29790 IP 数据包标示 16 PROTO&#x3D;ICMP 协议 ICMP 17 TYPE&#x3D;0 ICMP 类型 18 CODE&#x3D;0 ICMP 代码 19 ID&#x3D;1481 ICMP ID 20 SEQ&#x3D;1 ICMP SEQ 21 DF 表示不分段，此字段还可能为 MF&#x2F;FRAG 22 SPT TCP 或 UDP 中的源端口 23 DPT TCP 或 UDP 中的目的端口 24 LEN 传输层协议头长度 25 SEQ TCP 序列号 26 ACK TCP 应答号 27 WINDOWS IP 包头内的窗口大小 28 RES TCP-Flags 中 ECN bits 的值 29 CWR&#x2F;ECE&#x2F;URG&#x2F;ACK&#x2F;PSH&#x2F;RST&#x2F;SYN&#x2F;FIN TCP 标志位 30 URGP 紧急指针起点 31 OPT IP 或 TCP 选项 32 INCOMPLETE 不完整的数据包 33 SPI 当协议为 AHESP 时出现 34 [ ] 中括号出现在两个地方，在 ICMP 协议中作为协议头的递归使用；在数据包长度出现非法时用于指出数据实际长度 (5) 日志策略 a、 获取所有 TCP 日志 b、 获取所有 UDP 日志 c、 获取 ssh 的日志 自定义策略(1)禁止 ping 127.0.0.1 默认是通过的 应用策略 ping 不通了,图中 iptables 规则也有流量匹配 (2) 状态为已连接的放行 (3)只允许本机访问 80 应用策略后通过 curl 127.0.0.1 匹配策略(图中错误因为本机没有 80 服务) (4) 利用扩展模块 limit，可以实现 DoS 攻击防范 虚拟网络使用，SDN 交换机 Openvswitch 与 Linux namespace概述（1）Open vSwitch Open vSwitch（简称为 OVS）是由 Nicira Networks 主导的，运行在虚拟化平台（例如 KVM，Xen）上的虚拟交换机。在虚拟化平台上，OVS 可以为动态变化的端点提供 2 层交换功能，很好的控制虚拟网络中的访问策略、网络隔离、流量监控等等。 OVS 遵循 Apache 2.0 许可证, 能同时支持多种标准的管理接口和协议。OVS 也提供了对 OpenFlow 协议的支持，用户可以使用任何支持 OpenFlow 协议的控制器对 OVS 进行远程管理控制。 （2）网络名称空间 netns netns 是在 linux 中提供网络虚拟化的一个项目，使用 netns 网络空间虚拟化可以在本地虚拟化出多个网络环境。netns 可以让一台机器上模拟多个网络设备，是网络虚拟化的重要组成，将不同类型的网络应用隔离。一个 net namespace 拥有独立的独立的网卡空间，路由表，ARP 表，ip 地址表，iptables 等。 软件安装（1）netns 功能由系统网络配置工具 iproute2 提供，命令形式为 ip netns （2）openvswitch 安装 (3) 启动 openvswitch 并设置自启 (4) 安装抓包工具 tcpdump,网络配置工具 bridge-utils ip link 使用(1) 查看 ip link 帮助 (2) 新建网络接口 (3) 查看网络接口 注: 实验中此处 ID 号可能不同 (4) 使接口 UP (5) 删除接口 ip netns 使用(1) 查看 ip netns 帮助 (2) 创建一个名为 test 的 namespace (3) 查看所有 namespace (4) 查看名为 test 的 namespace (5) 进入名为 test 的 namespace,执行网络命令 (6) 退出 namespace (7)给 test 添加接口 tap1 (8) 启用 tap1 虚拟接口 (9) 给 tap1 虚拟接口配置 IP (10) 删除 test namespace openvswitch 使用(1) 查看 openvswitch 安装的命令工具 (2)添加网桥 br0 (3)列出 open vswitch 中所有的网桥 (4)判断网桥是否存在 (5)将网卡添加到网桥 br0 (6)查看 open vswitch 的网络状态 (7)在网桥 br0 中新建 openvswitch 网口 (8)列出网桥 br0 中所有端口 (9)列出所有连接到网卡 tap2 的网桥 (10)删除网桥 br0 上的网口 tap2 (11)设置网口 tap1 的 vlan tag 为 10 (13)从网桥 br0 删除网口 tap1, 并从系统删除虚拟网口 tap1 (14)删除网桥 br0 搭建网络防火墙实验场景实验网络拓扑 环境搭建利用 openvswitch 创建 tag 为 10 和 11 的两个接口,结全 netns 模拟内网 1、内网 2。 1、开启主机路由转发功能 2、创建 tag 为 10 的内网 1 3、创建 tag 为 11 的内网 2，方法同上 4、查看网络内网 1 与 内网 2 的连通性 测试两个内网是不通的。 netns 模拟器由器实现内网 1 与内网 2 互通 在路由器内 ping 两个内网都是通的, 在内网 1 内 ping 内网 2 也是通的,实验环境搭建成功。 网络防火墙 nat、防问控制实战iptables nat 基础知识nat 表需要的三个链: 动作选项： 注意点: nat 常用配置(1) 将源转换成路由器 router 的 r2 接口地址 (2) 打开两个终端利用 tcpdump 抓包分析 注意：b 操作需要 ctrl + alt + f2 切换到新的视图操作,验证后 ctrl + c 中止抓包，按 ctrl + alt + f1 回到 a 视图继续下面的实验 (3) 配置 SNAT (4) 配置 DNAT 注: 因本实验机未安装 80 服务,所以 curl  错误 (5) 重定向 网络防火墙(1) 允许内网１访问内问２ 注：有数据包匹配说明规则生效 (2) 拒绝内网１访问内网２ (3) 拒绝内网１访问内网２的 80 服务 注：需要按 ctrl+c 结束curl 公有云中二层防火墙实现实验网络修改(1) 实验拓扑 (2) 查看上个实验环境 (3) 清空配置 (4) 搭建实验环境 A.新建网桥 br0 B.配置内网 1 C.配置内网 2 D.测试二层同网段通信 (5) 加载内核参数 (6) 二层防火墙配置 A.把 FORWARD 链所有流量导入自定义链 B.添加内网 1 in、out 方向链表，将匹配到的 physdev 流量倒入进出链表 C.添加内网 1 in 方向规则, 并将没有匹配的流量导入新链表，过滤源地址使用 ipset 管理 D.添加内网 1 out 方向规则，将所有流量导入新的链过滤 E.添加内网 1 安全规则 F.拒绝未匹配的流量 G.测试内网 1 与内网 2 的网络连通性 可以看到已经不通了, 二层防火墙策略已经生效。 H.ipset 添加源地址内网 2,验证连通性 ipset 是 iptables 的扩展,可以想像它是一个 IP 地址集合,可以动态的加载 iptables 规则的地址集, 有效提升 iptables 的查找效率。 I.验证内网 1 能否修改 IP、MAC 注: 每次实验的 MAC 地址不一样, 请自行使用自己实验中的 MAC 实验中的方式就是公有云中二层防火墙实现的一种方法。可以控制同网段虚拟机间的通信,也可以防止用户随意修改 IP 或者 MAC 地址。"},{"title":"网络安全VPN实验","date":"2024-09-09T19:26:38.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8VPN%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"使用IP命令搭建基于隧道的虚拟专有网络登录和修改主机名称双击桌面Xshell5图标，在弹出的界面登陆主机 192.168.1.11和 192.168.2.11这两台主机.密码为 Simplexue123： 分别修改主机名： 重新登陆两台主机后： vpn1和vpn2主机分别加载gre内核模块并检查加载ip_gre内核模块 查询ip_gre模块是否加载： 配置tunnel（GRE隧道）使它们互通vpn1创建一个GRE类型隧道设备gre1, 并设置对端IP为192.168.2.11。隧道数据包将被从192.168.1.11也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.1，掩码为255.255.255.0。 创建GRE类型隧道设备gre1，并验证是否添加成功 启动gre1并分配ip地址10.10.10.1，检测是否添加并启动 查看隧道状态 对vpn2复刻上面的操作vpn2创建一个GRE类型隧道设备gre1, 并设置对端IP为192.168.1.11。隧道数据包将被从192.168.2.11也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.2，掩码为255.255.255.0。 测试隧道是否通 卸载GRE模块 使用加密工具OpenSSL创建加密密钥查看openssl命令的基本帮助 生成私钥生产RSA私钥(无加密) 生成rsa_private.key私钥对应的公钥 生成RSA含密码（使用aes256加密）公私钥 加密与非加密之间的转换 生成自签名证书 若执行自动输入，可使用-subj选项： 使用 已有RSA 私钥生成自签名证书 -new 指生成证书请求，加上 -x509 表示直接输出证书，-key 指定私钥文件，其余选项与上述命令相同 生成签名请求及CA 签名 OpenVPN的安装配置在vpn1机器安装openvpn并验证修改yum源 修改openvpn的配置文件server.conf配置文件拷贝模板文件到配置文件目录下 修改openvpn服务端的配置文件 配置DNS 设置启动用户 注释掉 explicit-exit-notify 1 安装密钥生成软件 shell [root@vpn1 ~]# yum install easy-rsa -y 准备配置证书文件 配置生成证书的环境变量.并使之生效 使配置的环境变量生效 根据提示先删除所有，再根据自己情况进行修改（默认回车即可） 建服务端的证书 创建通用名(common name)为”server”的证书文件,交互输入自己的值,回车键进行，在提示输入密码的地方，设置一个密码如simple123 生成防攻击的key文件（防DDos攻击、UDP淹没等恶意攻击） 建客户端证书 6.1.创建密钥文件，耗时间一分钟左右 可以看到有一个dh2048.pem的文件产生 拷贝密钥认证文件到配置文件目录下 创建一个通用名(common name)为 client的客户端证书，交互输入自己的值,默认回车键进行 启动并检查启动openvpn服务并设置为开机自启动 这里如果失败就尝试从配置环境变量的 ./clean-all步骤开始重试 客户端（vpn2）登录测试在客户端安装openvpn 在vpn1端把生产文件拷贝到客户端 编辑客户端配置文件 启动openvpn客户端并挂后台运行，并可实时查看其日志。 查看网卡信息，得知已获取到ip（建议新开一个Xshell窗口来进行以后的操作） 测试是否可使用 openvpn nat配置 关闭服务 IPsecVPN原理及安装配置调整配置文件和参数调整内核参数，开启数据转发，关闭icmp重定向并使之生效(两台主机都要完成) 将下面配置文件加入&#x2F;etc&#x2F;sysctl.conf 使配置生效 在VPN2上也做以上操作 安装openswan、libreswan并验证安装 启动服务看是否正常，显示如图测正常，若不是请检查内核配置文件，两台机器都验证 openswan监听在UDP的500和4500两个端口，其中500是用来IKE密钥交换协商，4500的NAT-T是nat穿透的 配置ipsecVPN配置（模式为network-to-network）下面介绍两种认证方式 基于pre-shared keys认证方式（PSK） 配置&#x2F;etc&#x2F;ipsec.conf配置文件末尾增加如下（VPN1和VPN2的配置文件相同） 两台机器是基于密码来配置的，修改VPN1和VPN2的密码配置文件 VPN1 VPN2 两端重新启动服务，并验证。VPN1 VPN2 必须两台都执行，否则不能成功。显示IPsec SA established tunnel mode 表示连接成功 测试由于只有两台机器，我们搭建虚拟内网网络来测试。 在VPN1上搭建虚拟网络10.0.0.1&#x2F;24 （步骤了解即可） 在VPN2上搭建虚拟网络10.0.1.1&#x2F;24 （步骤了解即可） 在VPN1上PING测试，可见可以ping通 ip netns exec left ping 10.0.1.2 在VPN1和VPN2上清除虚拟内网，停止服务。两台机器都执行。 云计算中基于Overlay技术的隧道网络实现在VPN1和VPN2分别安装openvswitch并启动服务安装openvswitch 启动服务 查看服务状态 配置VPN1在VPN1上添加名为br0的网桥： 给br0网桥分配一个ip 配置VPN2在VPN1上添加名为br0的网桥： 给br0网桥分配一个ip 搭建VXLAN隧道在VPN1上设置VXLAN，远端ip设置为VPN2能对外通信的br0的ip。 查看 在vpn2上设置VXLAN，远端ip设置为Host1能对外通信的br0的ip。 查看 验证验证VxLAN隧道 在VPN1上ping 10.1.0.2 发现可以通 "},{"title":"网络安全企业渗透实验","date":"2024-09-09T19:26:29.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BC%81%E4%B8%9A%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"WebLogic反序列化浏览器访问192.168.2.10 的 7001 端口 使用weblogic java 反序列化利用工具获取权限序列化和反序列化的含义 序列化：把对象转化为可传输的字节序列过程反序列化：把字节序列还原为对象的过程序列化的目的是为了对象可以跨平台存储和进行网络传输 首先在&#x2F;home&#x2F;Hack文件夹下找到反序列化利用工具WebLogic_EXP.jar 使用工具的指令如下： 输入Host和Port连接目标主机，并执行 ls -al命令，成功显示当前目录 在home目录下查找flag字样字符串提交执行命令 find / home -name flag定位到flag文件夹 执行命令 ls -al /home/flag查看 flag文件内容，发现 flag.txt 查看flag.txt内容： "},{"title":"网络安全漏洞挖掘实验","date":"2024-09-09T19:26:17.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"使用nmap和Metasploit进行漏洞挖掘和利用扫描192.168.1.0&#x2F;24下的所有主机的端口和操作系统信息 一共扫描到三台主机的IP地址、操作系统和端口信息 确定靶机地址为192.168.1.3，操作系统为Linux。 搜索攻击模块启动msf控制台 msfconsole并搜索类型为exploit的攻击模块 攻击和获取目标文件内容找到漏洞 VSFTPD v2.3.4 Backdoor Command Execution执行模块 exploit/unix/ftp/vsftpd_234_backdoor，设置lhost和rhost进行攻击 找到1.key文件并获取其内容： 使用nikto、crunch和burpsuite进行网站渗透和控制使用nikto工具查看网站目录结构并定位到管理员登陆界面 使用crunch命令生成字典命令： Firefox配置和Bursuit抓取在Firefox中先输入一个用户名和密码的值 然后进行Manual Proxy配置： ;查看截取到的用户名和密码 爆破Password字段设置攻击目标： 选择爆破对象： 添加爆破所使用的字典 尝试爆破，查看爆破的结果： 发现当使用admin452爆破时，所得到的结果和其他密码均不同，查看其得到的信息： 爆破成功，password值为admin452。使用该密码尝试登陆： 获取webshell权限并拿到目标机开放的远程桌面端口号设置用户自定义标记如图： Webshell提权在浏览器地址栏中输入“ (“whoami”);” ，执行命令“whoami”,显示webshell权限 查找目标主机开放的远程桌面端口将命令修改为 (“tasklist –svc”);来查找进程下的所有服务 找到COMSysApp svchost服务的PID为2088 然后输入 (“netstat -ano”);来查找COMSys svchost服务对应的端口号，即远程桌面端口 如图，远程桌面端口号为45565； 向目标机添加新用户并控制目标机添加新用户用户名：hacker，密码：Beijing123 不能使用管理员界面来添加，其添加的是后端用户，这里使用命令 (“net user hacker Beijing123 /add”);来添加。 将用户添加到管理员组使用命令 (“net localgroup Administrators hacker /add”);来将用户添加到管理员组 登录远程主机使用命令 rdesktop -u hacker1 -p Beijing123 192.168.1.4:45565远程登录目标主机。（此处使用hacker1 是由于之前设置错误） 登陆成功： 设置文件可读权限并查看内容在2.key文件的高级安全设置中更改权限，添加对象 hacker1 给予完全控制权限 保存，查看文件内容 文件内容为 Zenmap。"},{"title":"一次逆向实验","date":"2024-09-09T19:12:47.000Z","url":"/SeverusBlog/2024/09/10/%E4%B8%80%E6%AC%A1%E9%80%86%E5%90%91%E5%AE%9E%E9%AA%8C/","tags":[["逆向","/SeverusBlog/tags/%E9%80%86%E5%90%91/"]],"categories":[[" ",""]],"content":"既然建立了博客，之后我会搬一些以前写过的文档上来，好在使用markdown的时间比较早，因此也有不少的内容。(❁´◡&#96;❁) 这一篇是一次逆向作业，内容是分析两份可执行文件并逆向。 我的代码源码 这个程序是一个简单的学生成绩管理系统。用户可以输入两名学生的名字和他们的成绩，程序会计算每个学生的平均成绩，并输出他们是否通过。通过浮点数比较来判断学生是否通过，并最终输出结果。下面是分析部分 1. 函数开头 这些指令是函数的标准前序代码，用于保存调用者的环境和为局部变量分配空间。 2. 初始化变量并跳转到主循环 初始化 [esp+9Ch]为0，并跳转到地址 loc_401669，这是主循环的开始地址。 3. 主循环：输入学生姓名 提示用户输入学生姓名（通过 printf）。 读取用户输入的姓名（通过 scanf）。 4. 输入学生成绩 提示用户输入学生成绩。 读取用户输入的成绩（通过 scanf）。 更新计数器，检查是否需要继续输入成绩。 计算平均分并判断是否通过的部分 计算每个学生的平均成绩， 通过与固定的浮点数进行比较（flt_404084，很可能是及格线）判断他们是否通过。 根据比较结果输出“Pass”或“Fail”。 输出最终结果 在循环结束后，程序会输出最终结果信息，并结束程序。 逆向结果 同学代码源码 分析： 使用IDA打开我们编写的32位程序，如下图所示： 下面逐模块分析汇编代码。从main函数刚开始时开始： 这里是main函数最开始的一部分。可以看到，这里通过scanf函数输入了一个变量，其地址为esp+34Ch，并把该输入的值保存在eax中。接下来，程序将eax的值赋给esp+1B8h，将eax * 2 + 1的值赋给esp+348h。然后，程序从esp+1B8h拷贝了65h个字节到esp+24h处（由rep movsd和edi、esi的值判断出），由此我们可以判断出：这是一个结构体的赋值语句，并且结构体的大小为65h * 4字节，即404字节。我们将其暂时命名为my_struct。 然后接下来，程序定义了四个变量，我们不妨将上述五个变量，以及涉及到的两个结构体重命名为： 变量名 变量地址 变量类型 初始值 v1 esp+34Ch int scanf v2 esp+35Ch int 0 v3 esp+358h int 0 v4 esp+354h int 0 v5 esp+350h int 1 m1 esp+1B8h my_struct 偏移为0处赋值为v1 偏移为0x190处赋值为2 * v1 + 1 m2 esp+24h my_struct 赋值后的m1 特别的，因为0x348– 0x1B8 &#x3D; 0x190 &lt; 0x65 * 4 &#x3D; 0x194，所以我们可以判断出0x1B8在结构体m1中 定义完这些变量之后，程序跳转到了401630处执行。跳转到这个地方： 可以判断出，这里涉及到了一个条件判断：如果v5&lt;&#x3D;v1，则跳转到4015CC处，否则向下执行。姑且将401630处成为判断模块。 接下来跳转到4015CC处查看代码： 根据之前的的经验，我们可以看到这里涉及到了带有magic number的除法。 经计算我们可以得出： 在地址4015E5处，ecx&#x3D;v5，edx&#x3D;eax&#x3D;v5&#x2F;3； 在地址4015E9处，edx&#x3D;(v5&#x2F;3)*3； 在地址4015ED处，eax&#x3D;v5-(v5&#x2F;3)*3，也就是v5%3，这是一次取模运算。 总的来说，4015CC-4015ED这部分代码求出了v5%3，存储在eax中。接下来的程序将eax分别与1、2进行对比，根据比较的结果分别跳转到不同的地址，可以判断出这段是switch指令。 跳转到v5%3&#x3D;&#x3D;1的地址，即401609： 也就是v2+&#x3D;v5，然后跳转到401628处。 跳转到v5%3!&#x3D;2，也就是v5%3&#x3D;&#x3D;0的地址，即401619： 也就是v4+&#x3D;v5，然后不跳转，直接进入401628处。 判断完v5%3是否为1、2后，最后剩下的情况是v5%3&#x3D;&#x3D;2： 也就是v3+&#x3D;v5，然后跳转到401628处。也就是说，switch在401628处结束。跳转到这里： 也就是v5++，然后直接进入401630处，也就是判断模块处。 存在自增，而且有判断模块，并且先进入判断模块再执行主要内容（即switch函数），所以我们可以初步判断这里使用了for函数或者while函数。沿着判断模块后面的代码继续查看： 可以看到，这里除了传参数之外，还调用了一个函数summary，并且summary函数仅接受了一个参数v1。双击_summary，查看summary函数的内容： 这里定义了两个变量var4和var8，传入的参数存储在ebp+arg_0中。总体来说，这个函数的工作流程是： l var4&#x3D;0，var8&#x3D;1，跳转到401530； l 401530处，判断var8&lt;&#x3D;arg0是否成立，成立则跳转到401526，不成立则继续向下执行； l 如果成立，401526处，var4+&#x3D;var8，var8++，再次来到401530处； l 如果不成立，则eax&#x3D;var4，返回。 接下来回到main函数： 接下来，依次向printf函数传入了summary(v1)、v4、v3、ebp+1B4h、格式化字符串五个参数，调用printf函数之后程序结束。 接下来分析ebp+1B4h。m1的基地址是esp+1B8h，ebp+1B4h &lt; esp+1B8h，m2的基地址是esp+24h。也就是说，ebp+1B4h是m2的第0x64字节；换句话说，我们可以将其表示为m2.data[100]。 也就是说，主函数大致是这样的： "},{"title":"Github Pages上图片显示问题和添加评论","date":"2024-09-09T16:33:35.000Z","url":"/SeverusBlog/2024/09/10/Github-Pages%E4%B8%8A%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"把博客发布到Pages上后，遗憾地发现图片又不能显示了…重新看了下 index.html，又是路径的锅。 脚本处理有两种处理思路，一种是修改 index.html然后再提交到仓库，但是一来处理量大，二来有些地方匹配不到 image，因为直接把相对路径转化了。所以我选择处理自己的markdown文件，格式整齐，处理量小。 这里匹配 image并替换，deploy后再替换回来，编辑上就不会有问题了。 如你所见，这是个python程序，需要有python环境才能运行。 添加评论主要是发现主题有这个配置选项，顺便就加上吧。 这里选择的是Valine评论系统，一个无后端评论系统。链接 首先注册LeanCloud账号 创建应用 、 应用创建好以后，进入刚刚创建的应用，选择左边的 设置&gt;应用凭证，找到 AppID和 AppKey 修改配置文件 重新 hexo g -d应该就能看到评论区。"},{"title":"Hexo + Github Pages","date":"2024-09-09T14:03:38.000Z","url":"/SeverusBlog/2024/09/09/Hexo-Github-Page/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"本来我打算租用一个服务器来部署这个博客网站的，偶然间发现可以使用Github的Pages服务来进行部署。无论从经济还是实用性的角度感觉都更加优秀。 建立仓库注册Github和SSH本地连接的部分就不详细介绍了， 直接从建立仓库开始说起。 建立仓库的界面如下，创建什么仓库名并不重要。可以选择初始化仓库生成一个README文件。 点击 Create repository后就创建完了。 我们需要创建的是一个Github Pages仓库，现在打开仓库的Settings中的Pages，进行如下设置，注意点击Save保存。 出现这样的界面说明已经设置好了。 访问上面框中的网址就能访问你创建的网页了，比如这里创建个新的 index.html，随便输入点内容就可以访问试试看。 配置Git用户名和邮箱一般来说都配置好了，所以下面只放命令（在Git Bash中输入） 把本地Hexo博客发布到Github Pages上首先安装插件 hexo-deployer-git。也可以用cnpm下载。 接下来要把本地目录和Github关联，也就是进行SSH连接，但SSH连接早在很久之前就完成过了，因此不再赘述。 我们直接打开hexo配置文件配置相关内容。这里我修改了一下仓库名，没有什么影响。 然后我们拉到最底下，进行deploy设置。 这个repo可以直接复制这里的链接： 现在已经配置好了，输入下面的命令后访问网页看看是否成功。 搭建成功，当然也可以从另外一个分支构建然后在主页加一个 README.md。"},{"title":"Hexo图片插入","date":"2024-09-08T15:06:50.000Z","url":"/SeverusBlog/2024/09/08/Hexo%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"在搭建完Hexo并写完第一篇博客之后，我发现一件郁闷的事，我插入的图片并没有成功显示。 你现在能看到这张图片当然是我已经解决了这个问题，下面就将介绍解决方法。 插入图片首先我们要知道为什么会这样，我习惯在VSCode中编写markdown文件，而VSCode会在你插入图片的时候自动将图片存放在markdown同目录的image&#x2F;markdown同名文件夹下，比如你创建了一个1.md并插入了2.png，那么2.png的存放路径就是 hexo/source/_poimage/1/2.png，但是hexo读取时只判断绝对路径，这样我插入的图片就没办法正常加载。 起初我想使用相对路径转换的插件，然而发现该插件已经失效了： 随后我查询官方的解决方案，遗憾的发现官方的文档似乎也没有更新，其解决方案也不可用： 不过其并非毫无价值，我们了解到，在生成网页时，hexo默认根目录为source文件夹，如果使用相对路径引用的方式，要频繁的修改图片路径，不符合我使用VSCode节省时间的目的，所以我给出一种解决方案，即直接将image文件夹复制到source文件夹下，这样，相对路径被解析成绝对路径时也能读取到对应的图片内容。同时VSCode和Hexo上都能显示正确的图片内容。坏处在于使用了双倍的存储空间和每次编辑结束时需要复制一遍文件，似乎这样并不符合简约的理念🤔。 😁😁如果真的需要每次都复制一次图片，那就没必要使用VSCode了，我在VSCode中使用Office Viewer(Markdown)这个插件来编写markdown文档，只需要在该插件扩展设置中将hexo这个工作区中特别设置image的存放地址，那么就可以实现无需任何额外操作的编辑和hexo显示了。虽然有点取巧，但是比起图床上传网络和使用网络地址，改变自己的编辑器还是简单些，也更方便我管理。"},{"title":"Hexo博客搭建","date":"2024-09-08T14:21:14.000Z","url":"/SeverusBlog/2024/09/08/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"今天心血来潮想搭建一个个人博客，将自己在技术学习过程中的经历与遇到的小问题都记录在博客上，博客先部署在主机上，之后会部署到服务器中。既然搭建了博客，第一篇文章不妨就记录一下这个Hexo博客的搭建过程吧。 环境配置Hexo的环境其实很简单，安装了 Git和 Node.js基础环境就安装好了。在Windows环境下都是去官网下载安装即可。 输入 git -v、node -v和 npm -v即可检查是否安装成功。 安装Hexo这一步更简单，只要在命令行中输入下面的命令即可安装： 建站输入下面命令初始化Hexo： 输入下面命令启动Hexo： 这样就可以从我们本地的4000端口上访问了，如果你有公网IP，也可以从公网IP的端口访问，像我一样没有的话可以租用云服务器或者是用内网穿透服务来从公网访问。 当然默认的主题并不是这个样子，因此下面顺便介绍一下怎么切换主题。 更换主题打开 ，这是Hexo官方的主题收录站，我就是从这里找到的目前正在使用的主题Cards。当然直接在Github上搜索Hexo也能搜到不少定制的主题。 我个人更喜欢极简的风格，所以选择Cards作为示例。 简单的来说，你只需要在博客的根目录输入下面这条Git命令就可以安装主题了： 当然你需要把_config.yml中的主题名更换一下。 博客的标题和一些其他配置都可以到主题的配置文件中去修改： 接下来重新启动Hexo即可。 如果恰好遇上了无法 git clone的问题，可以直接下载压缩包并解压到themes文件夹中，记得重命名文件夹名称。"},{"title":"tags","date":"2024-09-08T12:54:51.000Z","url":"/SeverusBlog/tags/index.html","categories":[[" ",""]]},{"title":"search","date":"2024-09-08T17:31:25.000Z","url":"/SeverusBlog/search/index.html","categories":[[" ",""]]},{"date":"2025-02-27T11:28:25.932Z","url":"/SeverusBlog/README.html","categories":[[" ",""]],"content":"Website"}]