[{"title":"记一次面试之回溯法求解数组分割问题","date":"2024-11-21T08:11:16.000Z","url":"/SeverusBlog/2024/11/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%B1%82%E8%A7%A3%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98/","tags":[["-面试题","/SeverusBlog/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"categories":[[" ",""]],"content":"今天进行了一次技术面试，前面还能和面试官聊的比较好，直到我错了一个C的基础知识，感觉有点紧张，面试官让我屏幕共享做一道算法题，由于之前没有共享屏幕做题的经历，紧张感更强了，有点担心写不完题目，知道要用回溯法，但是一时之间没法组织出具体的代码。好在面试官让我展示了博客，允许我之后在博客上补全这个题目的结果，于是现在就来把这个题做完。 静态变量的存储位置和计算在做题之前，先记录一下回答错的C的知识，简单来说就是在函数内部静态定义了一个变量，之后再调用这个函数的时候，每次对这个变量自加并打印，会显示什么，我当时以为每次定义变量时都会重写变量，所以回答每次的结果都是一样的，后来面试官让我现场实验我才发现我错了，每次输出的数据都会自增，现在我来记录一下原因。 C语言中，如果在函数内部使用 static关键字定义一个变量，例如 static int a = 0;，这个变量会具有以下特点： 静态存储周期 ：变量 a的生命周期是整个程序运行期间，即使函数返回，变量 a的值也不会被销毁，而是保留原来的值。 局部作用域 ：变量 a的作用域依然是函数内部，不能在函数外部直接访问。 如以下的函数： 连续调用三次，其输出结果会是 这里需要说明一下，在C语言中，静态变量存储在 静态存储区 （也称为 全局数据区 ），具体细分为以下两部分： 数据段（Data Segment） 如果静态变量有显式初始化（如 static int a = 0;），它会存储在 已初始化的静态存储区 。 初始化值在程序加载时被写入对应的内存区域，程序运行时直接使用。 BSS段（Block Started by Symbol） 如果静态变量没有显式初始化（如 static int b;），它会存储在 未初始化的静态存储区 。 静态变量默认初始化为 零 ，即在程序加载时，该区域的所有字节会被清零。 所以我们的静态局部变量被存储在数据段中，而且初始化指令只会执行一次，这就是为什么 a会自增而不是永远输出1。 逐步分析： 第一次调用函数时： 静态变量 a被初始化为 0（仅在程序执行到此处第一次调用时初始化一次）。 执行 a++，a变为 1。 打印 a的值，输出 1。 第二次调用函数时： 变量 a已经存在，并且值为上次调用后的 1。 执行 a++，a变为 2。 打印 a的值，输出 2。 第三次调用函数时： 变量 a的值为上次调用后的 2。 执行 a++，a变为 3。 打印 a的值，输出 3。 回溯法求解数组分割问题问题很简单，给一个数组 a[]，要求将其分割为两个和值相等的数组 b[]和 c[]。 这个问题是回溯法的经典运用，首先我们可以确定数组a[]的和值必须是偶数，不然一定没有答案。然后我们将 a[]的和除以二，就可以得到需要达到的数组和 target，只要能够找到一组符合要求的数组，那剩下的元素必然和值为 target，如果不是 target，说明条件是不成立的。这里我们要递归地寻找元素，然而每次递归之后都要恢复现场，这就是回溯法。 由于当时虽然想到使用回溯法，但脑子实在有点太紧张，以至于写的很慢而且没想清楚具体的代码结构，所以最后也只写了个大体的递归结构出来，被面试官叫停了，希望面试官能看到接下来我完善后的代码。 需要说明的是，由于最后的拆分步骤需要识别哪些元素已经被加入到 b中从而将剩余元素构建成 c，使用一个布尔类型数组 used来识别哪些元素是b使用的，这一数组也需要进行回溯。 代码及注释如下，这份代码命名比较抽象，可读性比较差，可以看后面规范化后的代码： 上面代码函数和变量命名略显抽象，因为我想思路的时候命名都比较随意，重新规范化命名函数和变量如下，可读性应该会好一点： 运行结果如下： 输入序列为 &#123;1, 5, 11, 5, 0&#125; 输入序列为 &#123;1，2&#125; 输入序列为 &#123;1，4，7，10&#125; 输入序列为 &#123;7, 47, 42, 15, 14, 10, 69, 96, 33, 69, 23, 6, 29, 33, 80, 32, 72, 34, 53, 24, 76, 66, 14, 76, 15, 14, 27, 89, 89, 65, 32, 57, 52, 20, 70, 77, 8, 59, 3, 8, 39, 17, 94, 9, 96, 36, 59, 61, 97, 49, 88, 4, 47, 87, 86, 17, 60, 30, 13, 68, 27, 24, 93, 83, 91, 33, 64, 98, 24, 12, 28, 10, 27, 93, 59, 17, 37, 44, 45, 57, 50, 67, 89, 94, 90, 86, 98, 56, 25, 39, 52, 87, 62, 49, 31, 61, 55, 4, 25, 26&#125; 输入序列为 &#123;1，2，8，99&#125; 结果输出均正确，这个问题也顺利解决了。 "},{"title":"LeetCode 2398: 预算内的最多机器人数目","date":"2024-09-12T18:15:19.000Z","url":"/SeverusBlog/2024/09/13/LeetCode-2398-%E9%A2%84%E7%AE%97%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%95%B0%E7%9B%AE/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"虽然刚学Java不久，但也不能天天做简单题，今天正好每日一题是一道困难题，就来做做看。 题目你有 n 个机器人，给你两个下标从 0 开始的整数数组 chargeTimes 和 runningCosts ，两者长度都为 n 。第 i 个机器人充电时间为 chargeTimes[i] 单位时间，花费 runningCosts[i] 单位时间运行。再给你一个整数 budget 。 运行 k 个机器人 总开销 是 max(chargeTimes) + k * sum(runningCosts) ，其中 max(chargeTimes) 是这 k 个机器人中最大充电时间，sum(runningCosts) 是这 k 个机器人的运行时间之和。 请你返回在 不超过 budget 的前提下，你 最多 可以 连续 运行的机器人数目为多少。 示例 1： 解释：可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 sum(2,1,3) &#x3D; 6 + 3 6 &#x3D; 24 ，小于 25 。可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。 示例 2： 提示： chargeTimes.length == runningCosts.length == n 1 &lt;= n &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt; 1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt; 1 &lt;= budget &lt;= 10&lt;sup&gt;15&lt;/sup&gt; 滑动窗口其实这个题目中比较关键的是连续这两个字，因为其实充电时间和运行时间什么的都只是需要计算的数据，而连续这两个字就代表了我们不能直接排序，而是要使用滑动窗口的方法。滑动窗口在思想上的表现就是一种子视图，通过动态控制这个视图的大小来截取数据，单次遍历即可实现。窗口左侧只能删除数据而右侧只能添加数据。窗口永远不会向左移动。在这个题目中我们删除或添加数据的方法就是计算总预算的值。运行时间的和是比较好计算的，但是最大充电时间这个值每次都要重新计算，会消耗大量计算时间，当然也有优化的办法，那就是使用双端队列来维护这个充电时间，用空间换时间，不过这个可以之后再讲，我们先拿出一份朴素的、超时的代码。 这份代码有多朴素呢，首先它能通过数据量比较小的测试用例，说明它的思想是对的，但是这里的滑动窗口没有用双指针来实现（偷懒ing🤗），然后每次都重算一遍最大充电时间和总运行时间，哪怕根本不用双端队列，也可以把总运行时间的运算抽离成每次循环只计算一次，但是我没有。所以总的来说，这份代码写的比较粗犷，自然而然也就超时了，不过相应的，也比较好读懂。放这份代码是为了介绍接下来双端队列的内容，方便看懂。 双端队列由于双端队列完全在这个滑动窗口中工作，所以介绍一下使用双指针实现的滑动窗口。 滑动窗口的双指针实现滑动窗口是一种通过一对指针（通常称为 left和 right）来动态调整子数组范围的技术。在遍历数组的过程中，右边界 right每次右移（扩大窗口），当某些条件满足（如总费用超过预算）时，左边界 left右移（缩小窗口）。滑动窗口能够在O(n)时间内遍历整个数组，并动态调整窗口的范围，从而避免嵌套循环。 在这个问题中，窗口表示当前可以操作的机器的范围： right 指针表示当前处理的机器。 left 指针表示窗口的左边界。 每次 right指针右移时，我们会计算当前窗口内的总费用，若费用超过预算，就移动 left指针缩小窗口。通过这种方式，我们可以在O(n)时间内找到最大数量的机器。 双端队列的介绍双端队列是一种可以在两端高效插入和删除元素的数据结构。这里我们使用它来维护滑动窗口内的最大值，这样我们可以在O(1)时间内获取窗口中的最大充电时间。 这个问题中，我们希望能够动态地得到当前窗口中机器的最大充电时间。如果使用上面的代码那样计算最大值，时间复杂度会很高。所以我们使用双端队列来保存数组的索引，并维护一个“递减队列”： 队列的左端 ：存储当前窗口中最大充电时间的索引。 队列的右端 ：存储接下来可能成为最大值的元素的索引。 简单来说，队列的最左端的索引值所在的位置一定在当前窗口中，如果left大于该索引值，队列就会删掉这个元素，从而使得下一个元素成为最大值。而每次right移动时都会加入一个新的索引到这个队列中，如果这个索引值对应的最大充电时间大于其左边的一些值，那么直接把这些值全部从队列中删掉。因为这些值都没有必要判断了，在一个只会右移的窗口中它们不再具有意义。 如何使用双端队列 当 right指针右移时，比较 chargeTimes[right]和双端队列的末尾。如果 chargeTimes[right]大于或等于队列末尾的元素，那么队列末尾元素就没用了，因为它永远不会成为窗口中的最大值。因此，移除队列末尾的元素，直到队列末尾的元素比 chargeTimes[right]大。 把 right对应的索引加入队列末尾。 如果滑动窗口的左边界（即 left）超出了队列中存储的最大值的范围（即 deque.peekFirst()），则移除队列的左端（也就是最大值）。 通过这个方法，队列的左端始终保存当前窗口中的最大值的索引，因此可以快速获取最大值。 每次 right指针右移时的操作实际上根据上面的原理可以写出来，每次 right指针的右移会有如下操作： 更新双端队列 ：将 chargeTimes[right]加入队列，确保队列中始终保持当前窗口的最大充电时间在队首。 更新窗口总运行费用 ：累加 runningCosts[right]到总费用中。 判断窗口总费用是否超过预算 ：如果超出预算，通过移动 left指针来缩小窗口，并相应地更新总运行费用和双端队列。 计算最大窗口大小 ：更新最大能操作的机器数量。 源码综上能得到下面这份源码： 虽然没达到100%，仍有进步空间，但感觉也不错了。"},{"title":"LeetCode 94: 二叉树的中序遍历","date":"2024-09-11T13:00:24.000Z","url":"/SeverusBlog/2024/09/11/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"题目给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 示例 2： 示例 3： 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 中序遍历的概念就当作是数据结构的复习了，稍微回顾一下中序遍历顺序的结构。简单来说三种遍历顺序都用递归算法来实现的话，就是访问根节点的时机。 中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则： （1）中序遍历左子树 （2）访问根结点 （3）中序遍历右子树 思路简单来说就是递归访问，按中序遍历的顺序先左再根最后右。如果要用迭代算法就引入一个栈的数据结构。 这里注意一下List的方法，java里 list没有 append和 insert方法，使用 add方法和addAll方法即可。 题解"},{"title":"LeetCode 82&83: 删除排序链表中的重复元素","date":"2024-09-11T10:54:53.000Z","url":"/SeverusBlog/2024/09/11/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"题目83给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例 1： 示例 2： 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 思路由于链表已经排好序了，检查下一个节点的数值并和当前节点比较应该就能解决这个问题吧。 题解就是基础的检查元素并删除节点的操作。 题目82为什么要先做83呢，因为83难度是简单但82是中等。 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例 1： 示例 2： 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 尝试思路什么的先放一边，我们把刚刚写的源码放进去再执行一遍，看看这题有什么不同。 原来这道题要把重复的节点全部删掉，这样就比刚刚复杂了。 思路就在此时我浮现了一个思路，既然是单向升序链表，也就是说，只要我设置把重复的节点val设成head的val-1或者-101，然后等全部执行完再遍历一遍删除，应该就能实现这个功能了。 理论存在，实践开始！ 题解首先引入一个标志 flag，这个标志负责记录当前节点有没有重复的下一节点，如果有则置1，等待该节点完成一般的删除重复节点操作后，在其即将进入下一个不重复的节点时修改当前节点的值为-101，然后再复位。当执行完一般的删除重复节点操作后，再从头指针开始遍历，遇到节点值为-101的情况就删除当前节点。需要注意的是，如果头节点的值为-101，则要执行特殊的删除循环结构，因为头节点没有前驱。同时注意一下null的情况，就可以完成这个题目了。 "},{"title":"LeetCode 67: 二进制求和","date":"2024-09-10T11:06:19.000Z","url":"/SeverusBlog/2024/09/10/LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","tags":[["LeetCode","/SeverusBlog/tags/LeetCode/"]],"categories":[[" ",""]],"content":"最近在学Java，所以重新刷一点LeetCode的简单题，尝试用Java来实现。 题目给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 示例 1： 示例 2： 提示： 1 &lt;= a.length, b.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; a 和 b 仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成 字符串如果不是 &quot;0&quot; ，就不含前导零 初步思路很显然，初步的思路有把字符串转换成整型进行加法后再转换成字符串和直接在字符串内从后向前遍历并设置进位器进行异或运算两种。从原理上后者似乎更接近硬件实现，但我们两种都可以尝试一下。 思路一源码 这份源码很好懂，总之就是先把字符串变成整数加算后再变回去，变回去的时候用的是递归运算。这份代码还有很大的优化空间，但是没什么必要，因为没通过测试用例。 原因很简单，我发现我看错了题目，是长度小于10000而不是数值小于10000…… 话不多说，直接进思路二。 思路二这个思路就是要求我们从后往前遍历字符串进行累加，倒也不算困难。 主要方法是建立一个含有进位存储器的异或方法，有点像寄存器，然后就可以用循环结构计算了。 在编写的过程中了解到 StringBuilder类中还有一个 Reverse()方法，可以直接逆序，很方便。 源码： 然而这份代码也是有问题的，他进位时会发生错误，无奈只能创建一个主类来进行调试了。 测试时发现，第一步计算 symbol时没有出现问题： 原因出在这里，第二次计算symbol时，又把进位值重置成0了，这就导致进位不生效。 由于三个个位二进制数加和永远不可能大于四，所以这里我们可以作如下修改： 本地测试一下，能进位了： 直接在LeetCode上提交，然后又错了： 又调试了一遍，还是这个进位的问题，忽视了进位与原数再产生进位的情况。 修改如下： 因为实际上三个数相加最多产生一次进位，为了不忽视两次运算的进位情况，将两次进位值异或即可。 再次提交就通过了。 时间复杂度和空间复杂度都是O(n)，显然不是最佳解法，看了一下题解，较好的方案把每个字符化成整型然后加法再变回字符和进位。相当于是我的思路一与思路二的结合体，我这种可能更接近于硬件方案吧。最后稍微优化了一些结构，源码及注释如下： "},{"title":"网络安全网络侦察实验","date":"2024-09-09T19:27:28.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"使用nmap、ettercap进行网络侦查和密码嗅探使用nmap工具进行网络侦察在Kali linux操作系统中打开操作终端，并使用nmap命令扫描192.168.1.0网段的存活主机，并探测该网段存活主机的开放端口、服务、操作系统及版本信息。 获得三台主机的信息： 分别扫描出了其端口信息、操作系统和版本信息。 使用ettercap工具进行密码嗅探使用嗅探工具对目标机的vsftpd服务进行嗅探。通过设置监听网卡、主机、开启arp欺骗、启动嗅探等步骤来嗅探网络内的数据包，获取ftp用户名和密码 在kali系统中打开ettercap的图形界面： 设置嗅探网卡：eth0 有线网卡 选择工具栏 Hosts-Host lists，并且使用 Scan for hosts来找出指定网段内的所有存活主机，并将其加入目标： 检查ip_forward是否为1，若不为1则需修改。 开始攻击，攻击方法为 ARP Poisoning 得到ftp的密码：ftp123 使用crunch、hydra暴力破解ssh服务使用crunch工具生成密钥在操作机使用相关工具，要求从字符串“hacker +123456”中，随机选9个字符进行排列组合，生成密码字典文件password.txt。 使用hydra爆破ssh 得到密码hacker123 使用ssh登录目标机并获取key值，获得敏感信息 1.key中内容是ettercap。 获取目标网站的webshell权限，控制目标机，获得敏感信息在操作机创建脚本，建立一个上传表单；建立一个php文件，作为一句话木马。通过上传表单上传一句话。 该网站网址是  我们选择这样的一句话木马： 其意义为执行GET请求中cmd的参数 我们将这这个一句话木马保存到 webshell.php中。 在浏览器另外一个页面快速打开 ，获得时间戳，分析可知上传的文件名以时间戳+下划线+原文件名称来命名。 我们选择用python编写脚本 我们将脚本文件和一句话木马文件准备好： 执行脚本文件： 测试命令phpinfo() 出现该页面说明我们的一句话木马上传成功了。 添加用户： 添加管理员： 输入命令 tasklist -svc 找到COMSysApp svchost服务的PID为2416 然后输入 netstat -ano来查找COMSys svchost服务对应的端口号，即远程桌面端口 如图，远程桌面端口号为35155； 远程连接并查看文件内容 修改文件属性 文件内容是 ftpstandrd123"},{"title":"网络安全入侵检测实验","date":"2024-09-09T19:27:03.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"在不同的操作系统环境下安装和配置OSSEC代理，构建入侵检测环境在Windows平台下安装和配置OSSEC代理安装OSSEC HIDS Windows Agent工具软件文件位置： C:/tools 目录下 设置OSSEC服务器IP 密钥由服务器生成 使用putty远程登录OSSIM服务器登陆设置： 登陆成功界面： 启动OSSEC代理管理程序找到位置：/var/ossec/bin/manage_agents 启动服务： 添加代理： 用户名：windows2012 ID：005 生成密钥： 在OSSET AGENT管理器窗口Authentication key栏里输入生成的密钥并保存 启动新建的OSSEC代理，查看该代理成功运行后的运行状态信息 在Linux平台下安装和配置OSSEC代理切换到CentOS7虚拟机 SSH连接 新建一个OSSEC代理和上面步骤相同，但是把代理名修改为CentOS7和把ID改为006。 查看密钥： 回到CentOS7，启动该系统上的manage_agents服务，然后输入密钥建立连接： 查看配置文件 发现没有对应配置，手动添加： 保存退出。 重启OSSEC服务重启方法为 查看代理状态 如图所示，CentOS7的代理服务已激活。 监视OSSIM服务器本地root用户的登录情况访问OSSIM集成监测平台网址：  查看配置信息在Analysis—&gt;Detection—&gt;HIDS—&gt;Config—&gt;Ossec.conf，可以看到OSSIM集成检测平台已经默认监视了日志文件&#x2F;var&#x2F;log&#x2F;auth.log 图形界面和命令行切换登录切换到alienvault用户，使用命令 ./ossec-control restart重启OSSIM服务器 这里需要使用VNC连接到192.168.1.200的主机上： 然后使用Crtl+Alt+F1进入界面并登录： 进入后再退出 然后在使用Crtl+Alt+F7组合键回到图形模式： 在windows2012上远程连接到服务器192.168.1.200前一个任务中已完成 查找日志在windows2012的OSSIM Web页面上，单击Analysis—&gt; Security Events (SIEM)，可以看到，Security Events页面中列出了OSSIM系统预设检测规则适用范围内的所有安全事件日志信息，可以找到通过putty远程登录时相关的SSH登录记录报警信息。该日志信息可作为系统管理员判断本次远程登录是否为非法入侵的重要报警信息。如果OSSIM服务器不允许root用户的远程登录操作，那么root用户的本次远程登录操作将被视为黑客入侵行为 root用户远程登录成功后OSSIM监测到的SShd登录成功的报警日志的signature信息： 进行ossec报警数据过滤 基于SSH的远程非法入侵检测登录并查看检测规则文件 修改一条规则 重启命令：/var/ossec/bin/ossec-control restart 用任意错误密码尝试登陆先把root设置为非法用户： vim/etc/ssh/sshd_config 重启服务：service ssh restart 得到错误密码报警： 监视CentOS7 root用户情况在OSSIM集成检测平台上设置规则，监测CentOS7用户情况 重启ossec服务。 创建用户 查找报警信息 监控Web服务器的访问日志修改ossec.conf文件 重启 访问 显示Not Found 查看报警信息 "},{"title":"网络安全防火墙实验","date":"2024-09-09T19:26:46.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"Linux 防火墙 Iptables 基础防火墙一些概念从防火墙作用范围讲，防火墙可以大体分为主机防火墙和网络防火墙。 网络防火墙和主机防火墙在企业网络架构中所处的网络位置不一样，它俩的结合能使企业网络更安全。 从产品形态讲，防火墙可以分为硬件防火墙和软件防火墙。 下面说说本实验的重点，Linux iptables。 iptables 其实它并不是真正的防火墙，我们可以理解它为一个命令行工具，位于用户空间，我们用这个工具操作”安全框架”。netfilter 是防火墙真正的安全框架（framework），netfilter 位于内核空间。 netfilter&#x2F;iptables（下文中简称为 iptables）组成 Linux 平台下的包过滤防火墙，与大多数的 Linux 软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 Netfilter 是 Linux 操作系统内核的一个数据包处理模块，主要有如下功能： Iptables 基础 表的概念 链的概念 表和链的对应关系： 同一链在不同表中的执行优先级次序（由高而低）： Iptables 使用语法Centos7 下可用 firewalld 和 iptables 两种防火墙管理方式,实验中使用 iptables。 基本语法格式： 链管理： 规则管理： 保存规则： 恢复规则: 规则查看： 登陆实验机 登陆帐号：root，登陆密码：Simplexue123 Iptables 简单使用使用 man 手册 查看 filter 表规则, iptables 默认使用 filter 表 添加规则,允许所有网络访问本机 注意：在不指定源、目的地址,源、目的 IP,协议的情况下为全部 IP、端口、协议为 FORWARD 链添加默认规则 添加自定链 test 删除自定链 test Iptables 主机防火墙和审计常用语法对于任何协议及协议的扩展，通用匹配都可以直接使用。 （1）匹配指定协议。 -p，–protocol 例: iptables -A INPUT -p tcp -j ACCEPT 说明匹配指定的协议，指定协议的形式有以下几种： （2）以 IP 源地址匹配包。 -s，–src，–source 例: iptables -A INPUT -s 192.168.0.1 -j ACCEPT 说明以 IP 源地址匹配包。地址的形式如下： （3）以 IP 目的地址匹配包。 -d，–dst，–destination 例: iptables -A INPUT -d 192.168.0.1 -j ACCEPT 说明以 IP 目的地址匹配包。地址的形式和–source 完全一样。 （4）以包进入本地使用的网络接口匹配包。 -i例: iptables -A INPUT -i eth0 -j ACCEPT 说明以包进入本地所使用的网络接口来匹配包。要注意这个匹配操作只能用于 INPUT，FORWARD 和 PREROUTING 这三个链，用在其他任何地方会提示错误信息。指定接口有以下方法： （5）以包离开本地所使用的网络接口来匹配包。 -o例: iptables -A OUTPUT -o eth0 -j ACCEPT 说明以包离开本地所使用的网络接口来匹配包。要注意这个匹配操作只能用于 OUTPUT，FORWARD 和 POSTROUTING 这三个链，用在其他任何地方会提示错误信息。 （6）匹配通信源端口。 –source-port，–sport例: iptables -A INPUT -p tcp --sport 1111 说明当通信协议为 TCP 或 UDP 时，可以指定匹配的源端口，但必须与匹配协议相结合使用。 （7）匹配通信源端口。 – destination-port，–dport例: iptables -A INPUT -p tcp --dport 80 说明当通信协议为 TCP 或 UDP 时，可以指定匹配的目的端口，但必须与匹配协议相结合使用。 状态检测-m state –state {NEW,ESTATBLISHED,INVALID,RELATED},指定检测那种状态 （1）NEW:该包想要建立一个新的连接（重新连接或连接重定向）。 （2）RELATED:该包是属于某个已经建立的连接所建立的新连接。 （3）ESTABLISHED：该包属于某个已经建立的连接。 （4）INVALID:该包不匹配于任何连接，通常这些包被 DROP。 例: iptables -A INPUT -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT 特殊参数–icmp-type 指定 ICMP 的类型编号 例: iptables -A INPUT -p icmp --icmp-type 8 -m multiport 指定多端口号 –sport –dport –ports 例: iptables -A INPUT -p tcp -m multiport --dport 22,53,80,110 -m iprange 指定 IP 段 –src-range ip-ip –dst-range ip-ip 例: iptables -A INPUT -m iprange --src-range 192.168.1.2-192.168.1.7 -j DROP -m connlimit 连接限定 –comlimit-above # 限定大连接个数 例: iptables -A INPUT -p tcp --syn --dport 22 -m connlimit --connlimit-above 100 -j REJECT -m limit 现在连接速率，也就是限定匹配数据包的个数 –limit # 指定速率 –limit-burst # 峰值速率，最大限定 例: iptables -A INPUT -m limit --limit-burst 6 -m string 按字符串限定 –algo bm|kmp # 指定算法 bm 或 kmp –string “STRING” # 指定字符串本身 例: iptables -A OUTPUT -m string --string &quot;tudou.com&quot; --algo bm -j DROP iptables 常用的操作语法 功能 参数 语法 说明 添加规则 A iptables -A INPUT -p tcp -j ACCEPT 在 INPUT 链后加入允许所有 TCP 请求 删除规则 -D iptables -D INPUT -p tcp -j ACCEPT 在 INPUT 链中删除对应规则 自定义链重命名 -E iptables -E A B 将自定义链 A 重命名为 B，原来的名字在前，新名字在后 清空规则 -F iptables -F INPUT 清空 INPUT 链规则, 如果不加链名则是清除当前表所有规则 插入规则 -I iptables -I INPUT 1 -p tcp -j ACCEPT 在 INPUT 链内的某个位置插入规则，如果序号为 1 或没有序号，规则会被插入到的头部 显示规则 -L iptables -L INPUT 显示 INPUT 链的所有规则，如果没有指定链，则显示指定表中的所有链。精确输出可用-n 和-v 等参数 新建自定义链 -N iptables -N A 在指定表新建链 A,不可以同名 默认策略 -P iptables -P INPUT DROP 指定 INPUT 链的默认策略为 DROP, 可选策略 ACCEPT、DROP、REJECT、REDIRECT 替换规则 -R iptables -R INPUT 1 -p udp -j ACCETP 替换 INPUT 链中的第 1 条策略 删除用户自定义链 -X iptables -X A 删除指定表中的自定义链 A 计数器归零 -Z iptables -Z 清空指定表下指定链（如未指定则认为所有链）的所有计数器归零 iptables 日志记录Linux 下单独记录 Iptables 日志,编辑&#x2F;etc&#x2F;syslog.conf 文件，加入一行 重启 rsyslog 服务生效： 例: 记录源为 127.0.0.1 为来的所有 ICMP 日志 (1) 配置 iptables 策略 (2) 验证规则 图中 pkts 有两个数据包匹配 (3) 查看日志 (4) 上例 iptables 日志字段解释(编号 21 后为未用到的字段) 编号 字段 说明 1 Apr 27 20:28:57 日期时间，由 syslog 生成 2 localhost 主机名称 3 kernel syslogd 获取 kernel 产生的日志 4 iptables icmp-localhost 记录前缀，由用户指定—log-prefix “iptables icmp-localhost” 5 IN&#x3D;lo 数据包进入的接口，若为空表示本机产生 6 OUT&#x3D; 数据包流出的接口，若为空表示本机产生 7 MAC&#x3D;00:00:00:00:00:00:00:00:00:00:00:00:08:00 前 6 段为源 MAC, 后 6 段为目的 MAC 8 08:00 08:00 为上层协议代码，即表示 IP 协议 9 SRC&#x3D;127.0.0.1 源 IP 地址 10 DST&#x3D;127.0.0.1 目的 IP 地址 11 LEN&#x3D;84 IP 封包+承载数据的总长度(MTU) 12 TOS&#x3D;0x00 IP 包头内的服务类型字段，能反应服务质量包括延迟、可靠性和拥塞等 13 PREC&#x3D;0x00 服务类型的优先级字段 14 TTL&#x3D;64 IP 数据包的生存时间 15 ID&#x3D;29790 IP 数据包标示 16 PROTO&#x3D;ICMP 协议 ICMP 17 TYPE&#x3D;0 ICMP 类型 18 CODE&#x3D;0 ICMP 代码 19 ID&#x3D;1481 ICMP ID 20 SEQ&#x3D;1 ICMP SEQ 21 DF 表示不分段，此字段还可能为 MF&#x2F;FRAG 22 SPT TCP 或 UDP 中的源端口 23 DPT TCP 或 UDP 中的目的端口 24 LEN 传输层协议头长度 25 SEQ TCP 序列号 26 ACK TCP 应答号 27 WINDOWS IP 包头内的窗口大小 28 RES TCP-Flags 中 ECN bits 的值 29 CWR&#x2F;ECE&#x2F;URG&#x2F;ACK&#x2F;PSH&#x2F;RST&#x2F;SYN&#x2F;FIN TCP 标志位 30 URGP 紧急指针起点 31 OPT IP 或 TCP 选项 32 INCOMPLETE 不完整的数据包 33 SPI 当协议为 AHESP 时出现 34 [ ] 中括号出现在两个地方，在 ICMP 协议中作为协议头的递归使用；在数据包长度出现非法时用于指出数据实际长度 (5) 日志策略 a、 获取所有 TCP 日志 b、 获取所有 UDP 日志 c、 获取 ssh 的日志 自定义策略(1)禁止 ping 127.0.0.1 默认是通过的 应用策略 ping 不通了,图中 iptables 规则也有流量匹配 (2) 状态为已连接的放行 (3)只允许本机访问 80 应用策略后通过 curl 127.0.0.1 匹配策略(图中错误因为本机没有 80 服务) (4) 利用扩展模块 limit，可以实现 DoS 攻击防范 虚拟网络使用，SDN 交换机 Openvswitch 与 Linux namespace概述（1）Open vSwitch Open vSwitch（简称为 OVS）是由 Nicira Networks 主导的，运行在虚拟化平台（例如 KVM，Xen）上的虚拟交换机。在虚拟化平台上，OVS 可以为动态变化的端点提供 2 层交换功能，很好的控制虚拟网络中的访问策略、网络隔离、流量监控等等。 OVS 遵循 Apache 2.0 许可证, 能同时支持多种标准的管理接口和协议。OVS 也提供了对 OpenFlow 协议的支持，用户可以使用任何支持 OpenFlow 协议的控制器对 OVS 进行远程管理控制。 （2）网络名称空间 netns netns 是在 linux 中提供网络虚拟化的一个项目，使用 netns 网络空间虚拟化可以在本地虚拟化出多个网络环境。netns 可以让一台机器上模拟多个网络设备，是网络虚拟化的重要组成，将不同类型的网络应用隔离。一个 net namespace 拥有独立的独立的网卡空间，路由表，ARP 表，ip 地址表，iptables 等。 软件安装（1）netns 功能由系统网络配置工具 iproute2 提供，命令形式为 ip netns （2）openvswitch 安装 (3) 启动 openvswitch 并设置自启 (4) 安装抓包工具 tcpdump,网络配置工具 bridge-utils ip link 使用(1) 查看 ip link 帮助 (2) 新建网络接口 (3) 查看网络接口 注: 实验中此处 ID 号可能不同 (4) 使接口 UP (5) 删除接口 ip netns 使用(1) 查看 ip netns 帮助 (2) 创建一个名为 test 的 namespace (3) 查看所有 namespace (4) 查看名为 test 的 namespace (5) 进入名为 test 的 namespace,执行网络命令 (6) 退出 namespace (7)给 test 添加接口 tap1 (8) 启用 tap1 虚拟接口 (9) 给 tap1 虚拟接口配置 IP (10) 删除 test namespace openvswitch 使用(1) 查看 openvswitch 安装的命令工具 (2)添加网桥 br0 (3)列出 open vswitch 中所有的网桥 (4)判断网桥是否存在 (5)将网卡添加到网桥 br0 (6)查看 open vswitch 的网络状态 (7)在网桥 br0 中新建 openvswitch 网口 (8)列出网桥 br0 中所有端口 (9)列出所有连接到网卡 tap2 的网桥 (10)删除网桥 br0 上的网口 tap2 (11)设置网口 tap1 的 vlan tag 为 10 (13)从网桥 br0 删除网口 tap1, 并从系统删除虚拟网口 tap1 (14)删除网桥 br0 搭建网络防火墙实验场景实验网络拓扑 环境搭建利用 openvswitch 创建 tag 为 10 和 11 的两个接口,结全 netns 模拟内网 1、内网 2。 1、开启主机路由转发功能 2、创建 tag 为 10 的内网 1 3、创建 tag 为 11 的内网 2，方法同上 4、查看网络内网 1 与 内网 2 的连通性 测试两个内网是不通的。 netns 模拟器由器实现内网 1 与内网 2 互通 在路由器内 ping 两个内网都是通的, 在内网 1 内 ping 内网 2 也是通的,实验环境搭建成功。 网络防火墙 nat、防问控制实战iptables nat 基础知识nat 表需要的三个链: 动作选项： 注意点: nat 常用配置(1) 将源转换成路由器 router 的 r2 接口地址 (2) 打开两个终端利用 tcpdump 抓包分析 注意：b 操作需要 ctrl + alt + f2 切换到新的视图操作,验证后 ctrl + c 中止抓包，按 ctrl + alt + f1 回到 a 视图继续下面的实验 (3) 配置 SNAT (4) 配置 DNAT 注: 因本实验机未安装 80 服务,所以 curl  错误 (5) 重定向 网络防火墙(1) 允许内网１访问内问２ 注：有数据包匹配说明规则生效 (2) 拒绝内网１访问内网２ (3) 拒绝内网１访问内网２的 80 服务 注：需要按 ctrl+c 结束curl 公有云中二层防火墙实现实验网络修改(1) 实验拓扑 (2) 查看上个实验环境 (3) 清空配置 (4) 搭建实验环境 A.新建网桥 br0 B.配置内网 1 C.配置内网 2 D.测试二层同网段通信 (5) 加载内核参数 (6) 二层防火墙配置 A.把 FORWARD 链所有流量导入自定义链 B.添加内网 1 in、out 方向链表，将匹配到的 physdev 流量倒入进出链表 C.添加内网 1 in 方向规则, 并将没有匹配的流量导入新链表，过滤源地址使用 ipset 管理 D.添加内网 1 out 方向规则，将所有流量导入新的链过滤 E.添加内网 1 安全规则 F.拒绝未匹配的流量 G.测试内网 1 与内网 2 的网络连通性 可以看到已经不通了, 二层防火墙策略已经生效。 H.ipset 添加源地址内网 2,验证连通性 ipset 是 iptables 的扩展,可以想像它是一个 IP 地址集合,可以动态的加载 iptables 规则的地址集, 有效提升 iptables 的查找效率。 I.验证内网 1 能否修改 IP、MAC 注: 每次实验的 MAC 地址不一样, 请自行使用自己实验中的 MAC 实验中的方式就是公有云中二层防火墙实现的一种方法。可以控制同网段虚拟机间的通信,也可以防止用户随意修改 IP 或者 MAC 地址。"},{"title":"网络安全VPN实验","date":"2024-09-09T19:26:38.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8VPN%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"使用IP命令搭建基于隧道的虚拟专有网络登录和修改主机名称双击桌面Xshell5图标，在弹出的界面登陆主机 192.168.1.11和 192.168.2.11这两台主机.密码为 Simplexue123： 分别修改主机名： 重新登陆两台主机后： vpn1和vpn2主机分别加载gre内核模块并检查加载ip_gre内核模块 查询ip_gre模块是否加载： 配置tunnel（GRE隧道）使它们互通vpn1创建一个GRE类型隧道设备gre1, 并设置对端IP为192.168.2.11。隧道数据包将被从192.168.1.11也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.1，掩码为255.255.255.0。 创建GRE类型隧道设备gre1，并验证是否添加成功 启动gre1并分配ip地址10.10.10.1，检测是否添加并启动 查看隧道状态 对vpn2复刻上面的操作vpn2创建一个GRE类型隧道设备gre1, 并设置对端IP为192.168.1.11。隧道数据包将被从192.168.2.11也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.2，掩码为255.255.255.0。 测试隧道是否通 卸载GRE模块 使用加密工具OpenSSL创建加密密钥查看openssl命令的基本帮助 生成私钥生产RSA私钥(无加密) 生成rsa_private.key私钥对应的公钥 生成RSA含密码（使用aes256加密）公私钥 加密与非加密之间的转换 生成自签名证书 若执行自动输入，可使用-subj选项： 使用 已有RSA 私钥生成自签名证书 -new 指生成证书请求，加上 -x509 表示直接输出证书，-key 指定私钥文件，其余选项与上述命令相同 生成签名请求及CA 签名 OpenVPN的安装配置在vpn1机器安装openvpn并验证修改yum源 修改openvpn的配置文件server.conf配置文件拷贝模板文件到配置文件目录下 修改openvpn服务端的配置文件 配置DNS 设置启动用户 注释掉 explicit-exit-notify 1 安装密钥生成软件 shell [root@vpn1 ~]# yum install easy-rsa -y 准备配置证书文件 配置生成证书的环境变量.并使之生效 使配置的环境变量生效 根据提示先删除所有，再根据自己情况进行修改（默认回车即可） 建服务端的证书 创建通用名(common name)为”server”的证书文件,交互输入自己的值,回车键进行，在提示输入密码的地方，设置一个密码如simple123 生成防攻击的key文件（防DDos攻击、UDP淹没等恶意攻击） 建客户端证书 6.1.创建密钥文件，耗时间一分钟左右 可以看到有一个dh2048.pem的文件产生 拷贝密钥认证文件到配置文件目录下 创建一个通用名(common name)为 client的客户端证书，交互输入自己的值,默认回车键进行 启动并检查启动openvpn服务并设置为开机自启动 这里如果失败就尝试从配置环境变量的 ./clean-all步骤开始重试 客户端（vpn2）登录测试在客户端安装openvpn 在vpn1端把生产文件拷贝到客户端 编辑客户端配置文件 启动openvpn客户端并挂后台运行，并可实时查看其日志。 查看网卡信息，得知已获取到ip（建议新开一个Xshell窗口来进行以后的操作） 测试是否可使用 openvpn nat配置 关闭服务 IPsecVPN原理及安装配置调整配置文件和参数调整内核参数，开启数据转发，关闭icmp重定向并使之生效(两台主机都要完成) 将下面配置文件加入&#x2F;etc&#x2F;sysctl.conf 使配置生效 在VPN2上也做以上操作 安装openswan、libreswan并验证安装 启动服务看是否正常，显示如图测正常，若不是请检查内核配置文件，两台机器都验证 openswan监听在UDP的500和4500两个端口，其中500是用来IKE密钥交换协商，4500的NAT-T是nat穿透的 配置ipsecVPN配置（模式为network-to-network）下面介绍两种认证方式 基于pre-shared keys认证方式（PSK） 配置&#x2F;etc&#x2F;ipsec.conf配置文件末尾增加如下（VPN1和VPN2的配置文件相同） 两台机器是基于密码来配置的，修改VPN1和VPN2的密码配置文件 VPN1 VPN2 两端重新启动服务，并验证。VPN1 VPN2 必须两台都执行，否则不能成功。显示IPsec SA established tunnel mode 表示连接成功 测试由于只有两台机器，我们搭建虚拟内网网络来测试。 在VPN1上搭建虚拟网络10.0.0.1&#x2F;24 （步骤了解即可） 在VPN2上搭建虚拟网络10.0.1.1&#x2F;24 （步骤了解即可） 在VPN1上PING测试，可见可以ping通 ip netns exec left ping 10.0.1.2 在VPN1和VPN2上清除虚拟内网，停止服务。两台机器都执行。 云计算中基于Overlay技术的隧道网络实现在VPN1和VPN2分别安装openvswitch并启动服务安装openvswitch 启动服务 查看服务状态 配置VPN1在VPN1上添加名为br0的网桥： 给br0网桥分配一个ip 配置VPN2在VPN1上添加名为br0的网桥： 给br0网桥分配一个ip 搭建VXLAN隧道在VPN1上设置VXLAN，远端ip设置为VPN2能对外通信的br0的ip。 查看 在vpn2上设置VXLAN，远端ip设置为Host1能对外通信的br0的ip。 查看 验证验证VxLAN隧道 在VPN1上ping 10.1.0.2 发现可以通 "},{"title":"网络安全企业渗透实验","date":"2024-09-09T19:26:29.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BC%81%E4%B8%9A%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"WebLogic反序列化浏览器访问192.168.2.10 的 7001 端口 使用weblogic java 反序列化利用工具获取权限序列化和反序列化的含义 序列化：把对象转化为可传输的字节序列过程反序列化：把字节序列还原为对象的过程序列化的目的是为了对象可以跨平台存储和进行网络传输 首先在&#x2F;home&#x2F;Hack文件夹下找到反序列化利用工具WebLogic_EXP.jar 使用工具的指令如下： 输入Host和Port连接目标主机，并执行 ls -al命令，成功显示当前目录 在home目录下查找flag字样字符串提交执行命令 find / home -name flag定位到flag文件夹 执行命令 ls -al /home/flag查看 flag文件内容，发现 flag.txt 查看flag.txt内容： "},{"title":"网络安全漏洞挖掘实验","date":"2024-09-09T19:26:17.000Z","url":"/SeverusBlog/2024/09/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C/","tags":[["网络安全","/SeverusBlog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"使用nmap和Metasploit进行漏洞挖掘和利用扫描192.168.1.0&#x2F;24下的所有主机的端口和操作系统信息 一共扫描到三台主机的IP地址、操作系统和端口信息 确定靶机地址为192.168.1.3，操作系统为Linux。 搜索攻击模块启动msf控制台 msfconsole并搜索类型为exploit的攻击模块 攻击和获取目标文件内容找到漏洞 VSFTPD v2.3.4 Backdoor Command Execution执行模块 exploit/unix/ftp/vsftpd_234_backdoor，设置lhost和rhost进行攻击 找到1.key文件并获取其内容： 使用nikto、crunch和burpsuite进行网站渗透和控制使用nikto工具查看网站目录结构并定位到管理员登陆界面 使用crunch命令生成字典命令： Firefox配置和Bursuit抓取在Firefox中先输入一个用户名和密码的值 然后进行Manual Proxy配置： ;查看截取到的用户名和密码 爆破Password字段设置攻击目标： 选择爆破对象： 添加爆破所使用的字典 尝试爆破，查看爆破的结果： 发现当使用admin452爆破时，所得到的结果和其他密码均不同，查看其得到的信息： 爆破成功，password值为admin452。使用该密码尝试登陆： 获取webshell权限并拿到目标机开放的远程桌面端口号设置用户自定义标记如图： Webshell提权在浏览器地址栏中输入“ (“whoami”);” ，执行命令“whoami”,显示webshell权限 查找目标主机开放的远程桌面端口将命令修改为 (“tasklist –svc”);来查找进程下的所有服务 找到COMSysApp svchost服务的PID为2088 然后输入 (“netstat -ano”);来查找COMSys svchost服务对应的端口号，即远程桌面端口 如图，远程桌面端口号为45565； 向目标机添加新用户并控制目标机添加新用户用户名：hacker，密码：Beijing123 不能使用管理员界面来添加，其添加的是后端用户，这里使用命令 (“net user hacker Beijing123 /add”);来添加。 将用户添加到管理员组使用命令 (“net localgroup Administrators hacker /add”);来将用户添加到管理员组 登录远程主机使用命令 rdesktop -u hacker1 -p Beijing123 192.168.1.4:45565远程登录目标主机。（此处使用hacker1 是由于之前设置错误） 登陆成功： 设置文件可读权限并查看内容在2.key文件的高级安全设置中更改权限，添加对象 hacker1 给予完全控制权限 保存，查看文件内容 文件内容为 Zenmap。"},{"title":"一次逆向实验","date":"2024-09-09T19:12:47.000Z","url":"/SeverusBlog/2024/09/10/%E4%B8%80%E6%AC%A1%E9%80%86%E5%90%91%E5%AE%9E%E9%AA%8C/","tags":[["逆向","/SeverusBlog/tags/%E9%80%86%E5%90%91/"]],"categories":[[" ",""]],"content":"既然建立了博客，之后我会搬一些以前写过的文档上来，好在使用markdown的时间比较早，因此也有不少的内容。(❁´◡&#96;❁) 这一篇是一次逆向作业，内容是分析两份可执行文件并逆向。 我的代码源码 这个程序是一个简单的学生成绩管理系统。用户可以输入两名学生的名字和他们的成绩，程序会计算每个学生的平均成绩，并输出他们是否通过。通过浮点数比较来判断学生是否通过，并最终输出结果。下面是分析部分 1. 函数开头 这些指令是函数的标准前序代码，用于保存调用者的环境和为局部变量分配空间。 2. 初始化变量并跳转到主循环 初始化 [esp+9Ch]为0，并跳转到地址 loc_401669，这是主循环的开始地址。 3. 主循环：输入学生姓名 提示用户输入学生姓名（通过 printf）。 读取用户输入的姓名（通过 scanf）。 4. 输入学生成绩 提示用户输入学生成绩。 读取用户输入的成绩（通过 scanf）。 更新计数器，检查是否需要继续输入成绩。 计算平均分并判断是否通过的部分 计算每个学生的平均成绩， 通过与固定的浮点数进行比较（flt_404084，很可能是及格线）判断他们是否通过。 根据比较结果输出“Pass”或“Fail”。 输出最终结果 在循环结束后，程序会输出最终结果信息，并结束程序。 逆向结果 同学代码源码 分析： 使用IDA打开我们编写的32位程序，如下图所示： 下面逐模块分析汇编代码。从main函数刚开始时开始： 这里是main函数最开始的一部分。可以看到，这里通过scanf函数输入了一个变量，其地址为esp+34Ch，并把该输入的值保存在eax中。接下来，程序将eax的值赋给esp+1B8h，将eax * 2 + 1的值赋给esp+348h。然后，程序从esp+1B8h拷贝了65h个字节到esp+24h处（由rep movsd和edi、esi的值判断出），由此我们可以判断出：这是一个结构体的赋值语句，并且结构体的大小为65h * 4字节，即404字节。我们将其暂时命名为my_struct。 然后接下来，程序定义了四个变量，我们不妨将上述五个变量，以及涉及到的两个结构体重命名为： 变量名 变量地址 变量类型 初始值 v1 esp+34Ch int scanf v2 esp+35Ch int 0 v3 esp+358h int 0 v4 esp+354h int 0 v5 esp+350h int 1 m1 esp+1B8h my_struct 偏移为0处赋值为v1 偏移为0x190处赋值为2 * v1 + 1 m2 esp+24h my_struct 赋值后的m1 特别的，因为0x348– 0x1B8 &#x3D; 0x190 &lt; 0x65 * 4 &#x3D; 0x194，所以我们可以判断出0x1B8在结构体m1中 定义完这些变量之后，程序跳转到了401630处执行。跳转到这个地方： 可以判断出，这里涉及到了一个条件判断：如果v5&lt;&#x3D;v1，则跳转到4015CC处，否则向下执行。姑且将401630处成为判断模块。 接下来跳转到4015CC处查看代码： 根据之前的的经验，我们可以看到这里涉及到了带有magic number的除法。 经计算我们可以得出： 在地址4015E5处，ecx&#x3D;v5，edx&#x3D;eax&#x3D;v5&#x2F;3； 在地址4015E9处，edx&#x3D;(v5&#x2F;3)*3； 在地址4015ED处，eax&#x3D;v5-(v5&#x2F;3)*3，也就是v5%3，这是一次取模运算。 总的来说，4015CC-4015ED这部分代码求出了v5%3，存储在eax中。接下来的程序将eax分别与1、2进行对比，根据比较的结果分别跳转到不同的地址，可以判断出这段是switch指令。 跳转到v5%3&#x3D;&#x3D;1的地址，即401609： 也就是v2+&#x3D;v5，然后跳转到401628处。 跳转到v5%3!&#x3D;2，也就是v5%3&#x3D;&#x3D;0的地址，即401619： 也就是v4+&#x3D;v5，然后不跳转，直接进入401628处。 判断完v5%3是否为1、2后，最后剩下的情况是v5%3&#x3D;&#x3D;2： 也就是v3+&#x3D;v5，然后跳转到401628处。也就是说，switch在401628处结束。跳转到这里： 也就是v5++，然后直接进入401630处，也就是判断模块处。 存在自增，而且有判断模块，并且先进入判断模块再执行主要内容（即switch函数），所以我们可以初步判断这里使用了for函数或者while函数。沿着判断模块后面的代码继续查看： 可以看到，这里除了传参数之外，还调用了一个函数summary，并且summary函数仅接受了一个参数v1。双击_summary，查看summary函数的内容： 这里定义了两个变量var4和var8，传入的参数存储在ebp+arg_0中。总体来说，这个函数的工作流程是： l var4&#x3D;0，var8&#x3D;1，跳转到401530； l 401530处，判断var8&lt;&#x3D;arg0是否成立，成立则跳转到401526，不成立则继续向下执行； l 如果成立，401526处，var4+&#x3D;var8，var8++，再次来到401530处； l 如果不成立，则eax&#x3D;var4，返回。 接下来回到main函数： 接下来，依次向printf函数传入了summary(v1)、v4、v3、ebp+1B4h、格式化字符串五个参数，调用printf函数之后程序结束。 接下来分析ebp+1B4h。m1的基地址是esp+1B8h，ebp+1B4h &lt; esp+1B8h，m2的基地址是esp+24h。也就是说，ebp+1B4h是m2的第0x64字节；换句话说，我们可以将其表示为m2.data[100]。 也就是说，主函数大致是这样的： "},{"title":"Github Pages上图片显示问题和添加评论","date":"2024-09-09T16:33:35.000Z","url":"/SeverusBlog/2024/09/10/Github-Pages%E4%B8%8A%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"把博客发布到Pages上后，遗憾地发现图片又不能显示了…重新看了下 index.html，又是路径的锅。 脚本处理有两种处理思路，一种是修改 index.html然后再提交到仓库，但是一来处理量大，二来有些地方匹配不到 image，因为直接把相对路径转化了。所以我选择处理自己的markdown文件，格式整齐，处理量小。 这里匹配 image并替换，deploy后再替换回来，编辑上就不会有问题了。 如你所见，这是个python程序，需要有python环境才能运行。 添加评论主要是发现主题有这个配置选项，顺便就加上吧。 这里选择的是Valine评论系统，一个无后端评论系统。链接 首先注册LeanCloud账号 创建应用 、 应用创建好以后，进入刚刚创建的应用，选择左边的 设置&gt;应用凭证，找到 AppID和 AppKey 修改配置文件 重新 hexo g -d应该就能看到评论区。"},{"title":"Hexo + Github Pages","date":"2024-09-09T14:03:38.000Z","url":"/SeverusBlog/2024/09/09/Hexo-Github-Page/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"本来我打算租用一个服务器来部署这个博客网站的，偶然间发现可以使用Github的Pages服务来进行部署。无论从经济还是实用性的角度感觉都更加优秀。 建立仓库注册Github和SSH本地连接的部分就不详细介绍了， 直接从建立仓库开始说起。 建立仓库的界面如下，创建什么仓库名并不重要。可以选择初始化仓库生成一个README文件。 点击 Create repository后就创建完了。 我们需要创建的是一个Github Pages仓库，现在打开仓库的Settings中的Pages，进行如下设置，注意点击Save保存。 出现这样的界面说明已经设置好了。 访问上面框中的网址就能访问你创建的网页了，比如这里创建个新的 index.html，随便输入点内容就可以访问试试看。 配置Git用户名和邮箱一般来说都配置好了，所以下面只放命令（在Git Bash中输入） 把本地Hexo博客发布到Github Pages上首先安装插件 hexo-deployer-git。也可以用cnpm下载。 接下来要把本地目录和Github关联，也就是进行SSH连接，但SSH连接早在很久之前就完成过了，因此不再赘述。 我们直接打开hexo配置文件配置相关内容。这里我修改了一下仓库名，没有什么影响。 然后我们拉到最底下，进行deploy设置。 这个repo可以直接复制这里的链接： 现在已经配置好了，输入下面的命令后访问网页看看是否成功。 搭建成功，当然也可以从另外一个分支构建然后在主页加一个 README.md。"},{"title":"Hexo图片插入","date":"2024-09-08T15:06:50.000Z","url":"/SeverusBlog/2024/09/08/Hexo%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"在搭建完Hexo并写完第一篇博客之后，我发现一件郁闷的事，我插入的图片并没有成功显示。 你现在能看到这张图片当然是我已经解决了这个问题，下面就将介绍解决方法。 插入图片首先我们要知道为什么会这样，我习惯在VSCode中编写markdown文件，而VSCode会在你插入图片的时候自动将图片存放在markdown同目录的image&#x2F;markdown同名文件夹下，比如你创建了一个1.md并插入了2.png，那么2.png的存放路径就是 hexo/source/_poimage/1/2.png，但是hexo读取时只判断绝对路径，这样我插入的图片就没办法正常加载。 起初我想使用相对路径转换的插件，然而发现该插件已经失效了： 随后我查询官方的解决方案，遗憾的发现官方的文档似乎也没有更新，其解决方案也不可用： 不过其并非毫无价值，我们了解到，在生成网页时，hexo默认根目录为source文件夹，如果使用相对路径引用的方式，要频繁的修改图片路径，不符合我使用VSCode节省时间的目的，所以我给出一种解决方案，即直接将image文件夹复制到source文件夹下，这样，相对路径被解析成绝对路径时也能读取到对应的图片内容。同时VSCode和Hexo上都能显示正确的图片内容。坏处在于使用了双倍的存储空间和每次编辑结束时需要复制一遍文件，似乎这样并不符合简约的理念🤔。 😁😁如果真的需要每次都复制一次图片，那就没必要使用VSCode了，我在VSCode中使用Office Viewer(Markdown)这个插件来编写markdown文档，只需要在该插件扩展设置中将hexo这个工作区中特别设置image的存放地址，那么就可以实现无需任何额外操作的编辑和hexo显示了。虽然有点取巧，但是比起图床上传网络和使用网络地址，改变自己的编辑器还是简单些，也更方便我管理。"},{"title":"Hexo博客搭建","date":"2024-09-08T14:21:14.000Z","url":"/SeverusBlog/2024/09/08/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","tags":[["博客搭建","/SeverusBlog/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"]],"categories":[[" ",""]],"content":"今天心血来潮想搭建一个个人博客，将自己在技术学习过程中的经历与遇到的小问题都记录在博客上，博客先部署在主机上，之后会部署到服务器中。既然搭建了博客，第一篇文章不妨就记录一下这个Hexo博客的搭建过程吧。 环境配置Hexo的环境其实很简单，安装了 Git和 Node.js基础环境就安装好了。在Windows环境下都是去官网下载安装即可。 输入 git -v、node -v和 npm -v即可检查是否安装成功。 安装Hexo这一步更简单，只要在命令行中输入下面的命令即可安装： 建站输入下面命令初始化Hexo： 输入下面命令启动Hexo： 这样就可以从我们本地的4000端口上访问了，如果你有公网IP，也可以从公网IP的端口访问，像我一样没有的话可以租用云服务器或者是用内网穿透服务来从公网访问。 当然默认的主题并不是这个样子，因此下面顺便介绍一下怎么切换主题。 更换主题打开 ，这是Hexo官方的主题收录站，我就是从这里找到的目前正在使用的主题Cards。当然直接在Github上搜索Hexo也能搜到不少定制的主题。 我个人更喜欢极简的风格，所以选择Cards作为示例。 简单的来说，你只需要在博客的根目录输入下面这条Git命令就可以安装主题了： 当然你需要把_config.yml中的主题名更换一下。 博客的标题和一些其他配置都可以到主题的配置文件中去修改： 接下来重新启动Hexo即可。 如果恰好遇上了无法 git clone的问题，可以直接下载压缩包并解压到themes文件夹中，记得重命名文件夹名称。"},{"title":"tags","date":"2024-09-08T12:54:51.000Z","url":"/SeverusBlog/tags/index.html","categories":[[" ",""]]},{"title":"search","date":"2024-09-08T17:31:25.000Z","url":"/SeverusBlog/search/index.html","categories":[[" ",""]]}]