<!DOCTYPE html>
<html lang="zh_CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
    
    
    
    


    <!-- meta -->


<title>签名部分优化-GAUSS-04 | Severus&#39; Blog Site</title>


    <meta name="keywords" content="AVX2, Hawk">




    <!-- OpenGraph -->
 
    <meta name="description" content="字数：5710，阅读时间：29分钟 GAUSS函数具体优化采样前处理经过前三次分析，我们不难发现，由于算法内部比较难以优化，事实上目前最可行的方案就是并行化四个SHAKE实例的处理，这也是开发者留下的天然的用于AVX2优化的部分。 因此，下面这段我们暂且全部保留。 123456789101112131415161718192021222324252627const uint16_t *tab_hi">
<meta property="og:type" content="article">
<meta property="og:title" content="签名部分优化-GAUSS-04">
<meta property="og:url" content="https://severuszh.github.io/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-GAUSS-04/index.html">
<meta property="og:site_name" content="Severus&#39; Blog Site">
<meta property="og:description" content="字数：5710，阅读时间：29分钟 GAUSS函数具体优化采样前处理经过前三次分析，我们不难发现，由于算法内部比较难以优化，事实上目前最可行的方案就是并行化四个SHAKE实例的处理，这也是开发者留下的天然的用于AVX2优化的部分。 因此，下面这段我们暂且全部保留。 123456789101112131415161718192021222324252627const uint16_t *tab_hi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-27T11:08:20.000Z">
<meta property="article:modified_time" content="2025-03-03T06:22:32.487Z">
<meta property="article:author" content="Severus">
<meta property="article:tag" content="AVX2">
<meta property="article:tag" content="Hawk">
<meta name="twitter:card" content="summary_large_image">


    
<link rel="stylesheet" href="/SeverusBlog/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/SeverusBlog/css/highlight/highlight.css" media="none" >
        
    

    
    

    
    
<link rel="stylesheet" href="/SeverusBlog/css/style/dark.css">

    
<script src="/SeverusBlog/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 7.3.0"></head>

    <body>
        <div id="app" tabindex="-1">
            <header class="header">
    <div class="header__left">
        <a href="/SeverusBlog/" class="button">
            <span class="logo__text">Severus的个人小站</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/SeverusBlog/" class="navbar-menu button">首页</a>
                
                    <a href="/SeverusBlog/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/SeverusBlog/archives/" class="navbar-menu button">归档</a>
                
                    <a target="_blank" rel="noopener" href="https://github.com/SeverusZh" class="navbar-menu button">Github</a>
                
            </div>
        
        
        
    <a href="/SeverusBlog/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/SeverusBlog/" class="dropdown-menu button">首页</a>
                
                    <a href="/SeverusBlog/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/SeverusBlog/archives/" class="dropdown-menu button">归档</a>
                
                    <a target="_blank" rel="noopener" href="https://github.com/SeverusZh" class="dropdown-menu button">Github</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        签名部分优化-GAUSS-04
    </h1>
    <div class="post-title__meta">
        <a href="/SeverusBlog/archives/2025/02/" class="post-meta__date button">2025-02-27</a>
        
 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E5%89%8D%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">采样前处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%87%87%E6%A0%B7%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.</span> <span class="toc-text">主采样循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shake-extract-%EF%BC%9A%E5%8D%95%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96"><span class="toc-number">2.1.</span> <span class="toc-text">shake_extract()：单实例数据提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">2.3.</span> <span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shake-x4-extract-words-%EF%BC%9A%E5%9B%9B%E5%AE%9E%E4%BE%8B%E5%B9%B6%E8%A1%8C%E6%8F%90%E5%8F%96"><span class="toc-number">2.5.</span> <span class="toc-text">shake_x4_extract_words()：四实例并行提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">2.6.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91-1"><span class="toc-number">2.7.</span> <span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.8.</span> <span class="toc-text">关键设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.9.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%87%87%E6%A0%B7%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.</span> <span class="toc-text">内部采样循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E5%88%97%E6%9E%84%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">奇偶列构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E6%9F%A5%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">高斯分布查表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%80%A7%E8%B0%83%E6%95%B4"><span class="toc-number">3.3.</span> <span class="toc-text">奇偶性调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">符号处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%87%87%E6%A0%B7%E5%80%BC%E5%B9%B6%E7%B4%AF%E5%8A%A0%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="toc-number">3.5.</span> <span class="toc-text">存储采样值并累加平方和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%80%89%E5%8F%96"><span class="toc-number">3.6.</span> <span class="toc-text">随机数选取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%87%87%E6%A0%B7%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-number">3.7.</span> <span class="toc-text">主采样循环优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%9F%E6%83%B3"><span class="toc-number">4.</span> <span class="toc-text">感想</span></a></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E5%89%8D%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">采样前处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%87%87%E6%A0%B7%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.</span> <span class="toc-text">主采样循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shake-extract-%EF%BC%9A%E5%8D%95%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96"><span class="toc-number">2.1.</span> <span class="toc-text">shake_extract()：单实例数据提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">2.3.</span> <span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shake-x4-extract-words-%EF%BC%9A%E5%9B%9B%E5%AE%9E%E4%BE%8B%E5%B9%B6%E8%A1%8C%E6%8F%90%E5%8F%96"><span class="toc-number">2.5.</span> <span class="toc-text">shake_x4_extract_words()：四实例并行提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">2.6.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91-1"><span class="toc-number">2.7.</span> <span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.8.</span> <span class="toc-text">关键设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.9.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%87%87%E6%A0%B7%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.</span> <span class="toc-text">内部采样循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E5%88%97%E6%9E%84%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">奇偶列构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E6%9F%A5%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">高斯分布查表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%80%A7%E8%B0%83%E6%95%B4"><span class="toc-number">3.3.</span> <span class="toc-text">奇偶性调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">符号处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%87%87%E6%A0%B7%E5%80%BC%E5%B9%B6%E7%B4%AF%E5%8A%A0%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="toc-number">3.5.</span> <span class="toc-text">存储采样值并累加平方和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%80%89%E5%8F%96"><span class="toc-number">3.6.</span> <span class="toc-text">随机数选取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%87%87%E6%A0%B7%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-number">3.7.</span> <span class="toc-text">主采样循环优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%9F%E6%83%B3"><span class="toc-number">4.</span> <span class="toc-text">感想</span></a></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <p>字数：5710，阅读时间：29分钟</p>
<h1 id="GAUSS函数具体优化"><a href="#GAUSS函数具体优化" class="headerlink" title="GAUSS函数具体优化"></a>GAUSS函数具体优化</h1><h2 id="采样前处理"><a href="#采样前处理" class="headerlink" title="采样前处理"></a>采样前处理</h2><p>经过前三次分析，我们不难发现，由于算法内部比较难以优化，事实上目前最可行的方案就是并行化四个SHAKE实例的处理，这也是开发者留下的天然的用于AVX2优化的部分。</p>
<p>因此，下面这段我们暂且全部保留。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> *tab_hi;</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> *tab_lo;</span><br><span class="line"><span class="type">size_t</span> hi_len, lo_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (logn) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"> tab_hi = sig_gauss_hi_Hawk_256;</span><br><span class="line"> tab_lo = sig_gauss_lo_Hawk_256;</span><br><span class="line"> hi_len = SG_MAX_HI_Hawk_256;</span><br><span class="line"> lo_len = SG_MAX_LO_Hawk_256;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"> tab_hi = sig_gauss_hi_Hawk_512;</span><br><span class="line"> tab_lo = sig_gauss_lo_Hawk_512;</span><br><span class="line"> hi_len = SG_MAX_HI_Hawk_512;</span><br><span class="line"> lo_len = SG_MAX_LO_Hawk_512;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 10 */</span></span><br><span class="line"> tab_hi = sig_gauss_hi_Hawk_1024;</span><br><span class="line"> tab_lo = sig_gauss_lo_Hawk_1024;</span><br><span class="line"> hi_len = SG_MAX_HI_Hawk_1024;</span><br><span class="line"> lo_len = SG_MAX_LO_Hawk_1024;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> n = (<span class="type">size_t</span>)<span class="number">1</span> &lt;&lt; logn;</span><br><span class="line"><span class="type">uint8_t</span> seed[<span class="number">41</span>];</span><br><span class="line">rng(rng_context, seed, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>接下来，首先把高斯分布表展开成AVX2向量（这是当时尝试的方案，后面没有用到）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> __m256i avx2_256_tab_hi[hi_len];</span><br><span class="line">__m256i avx2_256_tab_low[lo_len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hi_len; i ++) &#123;</span><br><span class="line"> avx2_256_tab_hi[i] = _mm256_set1_epi64x(tab_hi[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; lo_len; i ++) &#123;</span><br><span class="line"> avx2_256_tab_low[i] = _mm256_set1_epi64x(tab_lo[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mm256_set1_epi64x</code> 是 Intel AVX 指令集中的一个内联函数，其核心作用是将一个 64 位有符号整数（<code>long long</code> 或 <code>__int64</code> 类型）重复填充到 256 位 SIMD 向量寄存器（<code>__m256i</code> 类型）的所有 64 位元素中。</p>
<p>此处需要说明一下hi_len和lo_len变量，事实上，二者是由这一段代码定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> sig_gauss_hi_Hawk_256[] = &#123;</span><br><span class="line"> <span class="number">0x4D70</span>, <span class="number">0x268B</span>,</span><br><span class="line"> <span class="number">0x0F80</span>, <span class="number">0x04FA</span>,</span><br><span class="line"> <span class="number">0x0144</span>, <span class="number">0x0041</span>,</span><br><span class="line"> <span class="number">0x000A</span>, <span class="number">0x0001</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_MAX_HI_Hawk_256  ((sizeof sig_gauss_hi_Hawk_256) / sizeof(uint16_t))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> sig_gauss_lo_Hawk_256[] = &#123;</span><br><span class="line"> <span class="number">0x71FBD58485D45050</span>, <span class="number">0x1408A4B181C718B1</span>,</span><br><span class="line"> <span class="number">0x54114F1DC2FA7AC9</span>, <span class="number">0x614569CC54722DC9</span>,</span><br><span class="line"> <span class="number">0x42F74ADDA0B5AE61</span>, <span class="number">0x151C5CDCBAFF49A3</span>,</span><br><span class="line"> <span class="number">0x252E2152AB5D758B</span>, <span class="number">0x23460C30AC398322</span>,</span><br><span class="line"> <span class="number">0x0FDE62196C1718FC</span>, <span class="number">0x01355A8330C44097</span>,</span><br><span class="line"> <span class="number">0x00127325DDF8CEBA</span>, <span class="number">0x0000DC8DE401FD12</span>,</span><br><span class="line"> <span class="number">0x000008100822C548</span>, <span class="number">0x0000003B0FFB28F0</span>,</span><br><span class="line"> <span class="number">0x0000000152A6E9AE</span>, <span class="number">0x0000000005EFCD99</span>,</span><br><span class="line"> <span class="number">0x000000000014DA4A</span>, <span class="number">0x0000000000003953</span>,</span><br><span class="line"> <span class="number">0x000000000000007B</span>, <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_MAX_LO_Hawk_256  ((sizeof sig_gauss_lo_Hawk_256) / sizeof(uint64_t))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> sig_gauss_hi_Hawk_512[] = &#123;</span><br><span class="line"> <span class="number">0x580B</span>, <span class="number">0x35F9</span>,</span><br><span class="line"> <span class="number">0x1D34</span>, <span class="number">0x0DD7</span>,</span><br><span class="line"> <span class="number">0x05B7</span>, <span class="number">0x020C</span>,</span><br><span class="line"> <span class="number">0x00A2</span>, <span class="number">0x002B</span>,</span><br><span class="line"> <span class="number">0x000A</span>, <span class="number">0x0001</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_MAX_HI_Hawk_512  ((sizeof sig_gauss_hi_Hawk_512) / sizeof(uint16_t))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> sig_gauss_lo_Hawk_512[] = &#123;</span><br><span class="line"> <span class="number">0x0C27920A04F8F267</span>, <span class="number">0x3C689D9213449DC9</span>,</span><br><span class="line"> <span class="number">0x1C4FF17C204AA058</span>, <span class="number">0x7B908C81FCE3524F</span>,</span><br><span class="line"> <span class="number">0x5E63263BE0098FFD</span>, <span class="number">0x4EBEFD8FF4F07378</span>,</span><br><span class="line"> <span class="number">0x56AEDFB0876A3BD8</span>, <span class="number">0x4628BC6B23887196</span>,</span><br><span class="line"> <span class="number">0x061E21D588CC61CC</span>, <span class="number">0x7F769211F07B326F</span>,</span><br><span class="line"> <span class="number">0x2BA568D92EEC18E7</span>, <span class="number">0x0668F461693DFF8F</span>,</span><br><span class="line"> <span class="number">0x00CF0F8687D3B009</span>, <span class="number">0x001670DB65964485</span>,</span><br><span class="line"> <span class="number">0x000216A0C344EB45</span>, <span class="number">0x00002AB6E11C2552</span>,</span><br><span class="line"> <span class="number">0x000002EDF0B98A84</span>, <span class="number">0x0000002C253C7E81</span>,</span><br><span class="line"> <span class="number">0x000000023AF3B2E7</span>, <span class="number">0x0000000018C14ABF</span>,</span><br><span class="line"> <span class="number">0x0000000000EBCC6A</span>, <span class="number">0x000000000007876E</span>,</span><br><span class="line"> <span class="number">0x00000000000034CF</span>, <span class="number">0x000000000000013D</span>,</span><br><span class="line"> <span class="number">0x0000000000000006</span>, <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_MAX_LO_Hawk_512  ((sizeof sig_gauss_lo_Hawk_512) / sizeof(uint64_t))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> sig_gauss_hi_Hawk_1024[] = &#123;</span><br><span class="line"> <span class="number">0x58B0</span>, <span class="number">0x36FE</span>,</span><br><span class="line"> <span class="number">0x1E3A</span>, <span class="number">0x0EA0</span>,</span><br><span class="line"> <span class="number">0x0632</span>, <span class="number">0x024A</span>,</span><br><span class="line"> <span class="number">0x00BC</span>, <span class="number">0x0034</span>,</span><br><span class="line"> <span class="number">0x000C</span>, <span class="number">0x0002</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_MAX_HI_Hawk_1024 ((sizeof sig_gauss_hi_Hawk_1024) / sizeof(uint16_t))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> sig_gauss_lo_Hawk_1024[] = &#123;</span><br><span class="line"> <span class="number">0x3AAA2EB76504E560</span>, <span class="number">0x01AE2B17728DF2DE</span>,</span><br><span class="line"> <span class="number">0x70E1C03E49BB683E</span>, <span class="number">0x6A00B82C69624C93</span>,</span><br><span class="line"> <span class="number">0x55CDA662EF2D1C48</span>, <span class="number">0x2685DB30348656A4</span>,</span><br><span class="line"> <span class="number">0x31E874B355421BB7</span>, <span class="number">0x430192770E205503</span>,</span><br><span class="line"> <span class="number">0x57C0676C029895A7</span>, <span class="number">0x5353BD4091AA96DB</span>,</span><br><span class="line"> <span class="number">0x3D4D67696E51F820</span>, <span class="number">0x09915A53D8667BEE</span>,</span><br><span class="line"> <span class="number">0x014A1A8A93F20738</span>, <span class="number">0x0026670030160D5F</span>,</span><br><span class="line"> <span class="number">0x0003DAF47E8DFB21</span>, <span class="number">0x0000557CD1C5F797</span>,</span><br><span class="line"> <span class="number">0x000006634617B3FF</span>, <span class="number">0x0000006965E15B13</span>,</span><br><span class="line"> <span class="number">0x00000005DBEFB646</span>, <span class="number">0x0000000047E9AB38</span>,</span><br><span class="line"> <span class="number">0x0000000002F93038</span>, <span class="number">0x00000000001B2445</span>,</span><br><span class="line"> <span class="number">0x000000000000D5A7</span>, <span class="number">0x00000000000005AA</span>,</span><br><span class="line"> <span class="number">0x0000000000000021</span>, <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_MAX_LO_Hawk_1024 ((sizeof sig_gauss_lo_Hawk_1024) / sizeof(uint64_t))</span></span><br></pre></td></tr></table></figure>

<p>其实这里的define写的挺莫名奇妙的，因为无论是256还是512或是1024的 <code>SG_MAX_LO</code>和 <code>SG_MAX_HI</code>都是一个固定的常数，也就是20&#x2F;26&#x2F;26和8&#x2F;10&#x2F;10，暂不清楚为什么要采取这样的除法定义，或许是当时写的时候为了方便泛用？</p>
<p>接下来，我们初始化四个SHAKE上下文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shake_context sc[<span class="number">4</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (sc_extra != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   sc[i] = *sc_extra;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   shake_init(&amp;sc[i], <span class="number">256</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  seed[<span class="number">40</span>] = (<span class="type">uint8_t</span>)i;</span><br><span class="line">  shake_inject(&amp;sc[i], seed, <span class="number">41</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接下来的flip操作需要进行一定的修改，我们发现开发者已经为优化预留出了结构 <code>shake_x4_context</code> 和函数 <code>shake_x4_flip</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="type">uint64_t</span> A[<span class="number">100</span>];</span><br><span class="line"> <span class="type">unsigned</span> dptr, rate;</span><br><span class="line">&#125; shake_x4_context;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">shake_x4_flip</span><span class="params">(shake_x4_context *scx4, <span class="type">const</span> shake_context *sc)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">  shake_context sct = sc[i];</span><br><span class="line">  shake_flip(&amp;sct);</span><br><span class="line">  <span class="built_in">memcpy</span>(scx4-&gt;A + (i * <span class="number">25</span>), sct.A, <span class="number">25</span> * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> scx4-&gt;dptr = scx4-&gt;rate = sc[<span class="number">0</span>].rate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们直接使用就好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shake_x4_context scx4;</span><br><span class="line">shake_x4_flip(&amp;scx4, sc);</span><br></pre></td></tr></table></figure>

<h2 id="主采样循环"><a href="#主采样循环" class="headerlink" title="主采样循环"></a>主采样循环</h2><p>首先要理解一下原来的union结构的含义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> b[<span class="number">40</span>];</span><br><span class="line">    <span class="type">uint16_t</span> w[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint64_t</span> q[<span class="number">5</span>];</span><br><span class="line">   &#125; buf;</span><br></pre></td></tr></table></figure>

<p>这个union结构的作用是向内存写入8位的变量b，然后使用16位的w和64位的q来进行访问，通过对一段内存的共享和视图访问来解决了复制造成的内存占用和时间开销。虽然在源代码中开发者根本没用到这一点，使得这一写法显得意义不明，但是在优化过程中我们却可以使用这个特点。可以在调用 <code>shake_x4_extract_words(&amp;scx4, buf.q, 5)</code> （没错，开发者也在 <code>sha3.c</code>中实现了这个函数）时，数据被写入 <code>q</code> 数组（视为 5 个 64 位字），然后通过 <code>y</code> 数组将数据视为 <code>__m256i</code> 向量，直接用于 AVX2 指令。<br>接下来的指令是 <code>shake_extract</code>的AVX2化版本 <code>shake_x4_extract_words</code>，我们有必要了解一下这个函数的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">shake_extract</span><span class="params">(shake_context *sc, <span class="type">void</span> *out, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> dptr, rate;</span><br><span class="line"> <span class="type">uint8_t</span> *buf;</span><br><span class="line"></span><br><span class="line"> dptr = sc-&gt;dptr;</span><br><span class="line"> rate = sc-&gt;rate;</span><br><span class="line"> buf = out;</span><br><span class="line"> <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="type">size_t</span> clen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dptr == rate) &#123;</span><br><span class="line">   process_block(sc-&gt;A);</span><br><span class="line">   dptr = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  clen = rate - dptr;</span><br><span class="line">  <span class="keyword">if</span> (clen &gt; len) &#123;</span><br><span class="line">   clen = len;</span><br><span class="line">  &#125;</span><br><span class="line">  len -= clen;</span><br><span class="line">  <span class="keyword">while</span> (clen -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   *buf ++ = (<span class="type">uint8_t</span>)(sc-&gt;A[dptr &gt;&gt; <span class="number">3</span>]</span><br><span class="line">    &gt;&gt; ((dptr &amp; <span class="number">7</span>) &lt;&lt; <span class="number">3</span>));</span><br><span class="line">   dptr ++;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> sc-&gt;dptr = (<span class="type">unsigned</span>)dptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">shake_x4_extract_words</span><span class="params">(shake_x4_context *scx4, <span class="type">uint64_t</span> *dst, <span class="type">size_t</span> num_x4)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> dptr = scx4-&gt;dptr;</span><br><span class="line"> <span class="type">size_t</span> rate = scx4-&gt;rate;</span><br><span class="line"> <span class="keyword">while</span> (num_x4 -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (dptr == rate) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">    process_block(scx4-&gt;A + (i * <span class="number">25</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   dptr = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">   dst[i] = scx4-&gt;A[(i * <span class="number">25</span>) + (dptr &gt;&gt; <span class="number">3</span>)];</span><br><span class="line">  &#125;</span><br><span class="line">  dptr += <span class="number">8</span>;</span><br><span class="line">  dst += <span class="number">4</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> scx4-&gt;dptr = (<span class="type">unsigned</span>)dptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shake-extract-：单实例数据提取"><a href="#shake-extract-：单实例数据提取" class="headerlink" title="shake_extract()：单实例数据提取"></a><strong><code>shake_extract()</code>：单实例数据提取</strong></h3><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h3><p>此函数用于 <strong>单个SHAKE实例的挤压阶段</strong>，将内部状态中的数据按字节提取到输出缓冲区。</p>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a><strong>核心逻辑</strong></h3><ol>
<li><strong>状态指针管理</strong>：<ul>
<li><code>dptr</code>：当前处理位置（字节级偏移）。</li>
<li><code>rate</code>：海绵结构的“速率”（单位：字节），即每次挤压阶段输出的最大数据量。</li>
</ul>
</li>
<li><strong>块置换触发</strong>：<ul>
<li>当 <code>dptr == rate</code> 时，调用 <code>process_block(sc-&gt;A)</code> 执行 <strong>Keccak-f置换</strong>（哈希核心操作），生成新的状态数据，并重置 <code>dptr</code> 为0。</li>
</ul>
</li>
<li><strong>逐字节提取</strong>：<ul>
<li>通过 <code>sc-&gt;A[dptr &gt;&gt; 3]</code> 定位到对应的64位字（<code>dptr &gt;&gt; 3</code> 等价于除以8）。</li>
<li>通过 <code>(dptr &amp; 7) &lt;&lt; 3</code> 计算字节在64位字内的偏移（左移3位等价于乘以8，得到比特偏移）。</li>
<li>示例：若 <code>dptr = 5</code>，则从 <code>sc-&gt;A[0]</code> 中提取第5个字节。</li>
</ul>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li>生成任意长度的哈希输出（如SHAKE-128&#x2F;256）。</li>
</ul>
<hr>
<h3 id="shake-x4-extract-words-：四实例并行提取"><a href="#shake-x4-extract-words-：四实例并行提取" class="headerlink" title="shake_x4_extract_words()：四实例并行提取"></a><strong><code>shake_x4_extract_words()</code>：四实例并行提取</strong></h3><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a><strong>功能</strong></h3><p>此函数用于 <strong>四个并行SHAKE实例的挤压阶段</strong>，批量提取64位字到目标数组，常用于SIMD优化或批量哈希计算。</p>
<h3 id="核心逻辑-1"><a href="#核心逻辑-1" class="headerlink" title="核心逻辑"></a><strong>核心逻辑</strong></h3><ol>
<li><strong>四实例状态管理</strong>：<ul>
<li>每个实例的状态存储在 <code>scx4-&gt;A</code> 中，内存布局为 <strong>四个连续的状态块</strong>，每个块占25个 <code>uint64_t</code>（对应SHA-3的1600位状态）。</li>
</ul>
</li>
<li><strong>块置换触发（并行）</strong>：<ul>
<li>当 <code>dptr == rate</code> 时，对四个实例依次调用 <code>process_block()</code>，执行Keccak-f置换。</li>
</ul>
</li>
<li><strong>批量提取64位字</strong>：<ul>
<li>每次从四个实例的状态中提取一个64位字（<code>dptr &gt;&gt; 3</code> 定位到字索引）。</li>
<li>示例：若 <code>dptr = 8</code>，则从每个实例的 <code>A[1]</code>（第二个64位字）提取数据。</li>
</ul>
</li>
</ol>
<h3 id="关键设计"><a href="#关键设计" class="headerlink" title="关键设计"></a><strong>关键设计</strong></h3><ul>
<li><strong>内存布局</strong>：四个实例的状态在内存中连续分布，间隔25个 <code>uint64_t</code>，便于向量化操作。</li>
<li><strong>高效提取</strong>：每次循环提取4个实例的64位字，直接写入目标数组，减少冗余操作。</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li>高性能计算（如同时生成多个哈希流）。</li>
<li>与SIMD指令（如AVX2）结合，加速批量哈希提取。</li>
</ul>
<p>顺便扩展一下Keccak-f 置换操作的细节，但在此处我们不需要优化它的实现。</p>
<p>Keccak-f 置换操作是 <strong>SHA-3 哈希算法家族（包括 SHAKE、SHA3-256 等）的核心组件</strong>，也是 Keccak 海绵结构的关键步骤。它通过多轮非线性变换对固定大小的内部状态（如 1600 比特）进行混淆和扩散，确保哈希输出的不可预测性和抗攻击性。</p>
<hr>
<p><strong>1. Keccak-f 的基本结构</strong></p>
<ul>
<li><p><strong>状态表示</strong>：</p>
<p>Keccak-f 将内部状态视为一个 <strong>5×5×w 的三维数组</strong>（<code>w = 2^ℓ</code>，例如 <code>w=64</code> 对应 1600 比特状态）。每个元素是一个 <code>w</code> 比特的“车道（lane）”。</p>
<ul>
<li>SHA-3 使用 <code>b=1600</code> 比特（即 <code>w=64</code>, <code>5×5×64=1600</code>）。</li>
<li>状态可视为 <code>5x5</code> 的矩阵，每个元素是一个 64 位整数。</li>
</ul>
</li>
<li><p><strong>轮数</strong>：</p>
<p>Keccak-f[b] 的轮数 <code>n</code> 取决于状态大小 <code>b</code>：</p>
<ul>
<li><code>b=1600</code>（SHA-3）时，轮数 <code>n=24</code>。</li>
<li>每轮包含 <strong>5 个非线性变换步骤</strong>（θ, ρ, π, χ, ι）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. Keccak-f 的 5 个步骤</strong></p>
<p>每轮操作对状态按顺序执行以下 5 个步骤：</p>
<p><strong>(1) θ（Theta）: 线性混合</strong></p>
<ul>
<li><strong>目标</strong>：增加状态的扩散性（Diffusion）。</li>
<li><strong>操作</strong>：每个比特的值受其相邻列和行的比特异或（XOR）影响。<ul>
<li>计算每列的奇偶校验（Parity）并异或到相邻列。</li>
</ul>
</li>
<li><strong>公式</strong>：<em>A</em>′[<em>x</em>][<em>y</em>][<em>z</em>]&#x3D;<em>A</em>[<em>x</em>][<em>y</em>][<em>z</em>]⊕(⨁<em>y</em>′&#x3D;04<em>A</em>[<em>x</em>−1][<em>y</em>′][<em>z</em>]⊕⨁<em>y</em>′&#x3D;04<em>A</em>[<em>x</em>+1][<em>y</em>′][<em>z</em>−1])</li>
</ul>
<p><strong>(2) ρ（Rho）: 比特循环移位</strong></p>
<ul>
<li><strong>目标</strong>：引入比特位置的混乱（Confusion）。</li>
<li><strong>操作</strong>：对每个车道（lane）进行固定偏移量的循环左移（Rotate）。<ul>
<li>偏移量由预定义的表格决定，例如 <code>A[1][0]</code> 循环左移 1 位。</li>
</ul>
</li>
</ul>
<p><strong>(3) π（Pi）: 行置换</strong></p>
<ul>
<li><strong>目标</strong>：打破对称性，增强非线性扩散。</li>
<li><strong>操作</strong>：将 <code>5x5</code> 矩阵的行按固定规则重新排列。<ul>
<li>新位置 <code>(x&#39;, y&#39;) = (y, (2x + 3y) \mod 5)</code>。</li>
</ul>
</li>
</ul>
<p><strong>(4) χ（Chi）: 非线性变换</strong></p>
<ul>
<li><strong>目标</strong>：引入非线性，抵抗线性密码分析。</li>
<li><strong>操作</strong>：对每行应用逻辑运算，使用 AND 和 NOT 操作。<ul>
<li>公式：<em>A</em>′[<em>x</em>][<em>y</em>]&#x3D;<em>A</em>[<em>x</em>][<em>y</em>]⊕((<em>NOT</em> <em>A</em>[<em>x</em>+1][<em>y</em>]) <em>AND</em> <em>A</em>[<em>x</em>+2][<em>y</em>])</li>
</ul>
</li>
</ul>
<p><strong>(5) ι（Iota）: 轮常量异或</strong></p>
<ul>
<li><strong>目标</strong>：打破每轮的对称性，防止固定点攻击。</li>
<li><strong>操作</strong>：在特定位置（<code>A[0][0]</code>）异或一个预定义的轮常量（Round Constant）。<ul>
<li>轮常量由伪随机算法生成，每轮不同。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>3. Keccak-f 的安全性与设计特点</strong></p>
<ul>
<li><strong>抗攻击性</strong>：<ul>
<li>通过多轮非线性步骤（尤其是 χ）抵抗差分和线性攻击。</li>
<li>ι 的轮常量防止攻击者利用对称性简化计算。</li>
</ul>
</li>
<li><strong>效率</strong>：<ul>
<li>位操作（AND&#x2F;XOR&#x2F;Shift）在硬件和软件中高效实现。</li>
<li>并行性：θ、ρ、π 步骤可并行计算（χ 需顺序处理）。</li>
</ul>
</li>
<li><strong>灵活性</strong>：Keccak-f 支持不同状态大小（如 200、400、800、1600 比特），适用于多种场景。</li>
</ul>
<hr>
<p><strong>4. Keccak-f 在海绵结构中的角色</strong></p>
<p>在 <strong>海绵结构（Sponge Construction）</strong> 中，Keccak-f 负责 <strong>吸收（Absorb）</strong> 和 <strong>挤压（Squeeze）</strong> 阶段的处理：</p>
<ol>
<li><strong>吸收阶段</strong>：<ul>
<li>输入数据分块与状态异或，每填充一个块后执行 Keccak-f 置换。</li>
</ul>
</li>
<li><strong>挤压阶段</strong>：<ul>
<li>从状态中提取输出数据，每次提取后可能需要执行 Keccak-f 置换以生成新状态。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>5. 示例：SHA3-256 中的 Keccak-f</strong></p>
<ul>
<li><strong>参数</strong>：<ul>
<li>状态大小 <code>b=1600</code> 比特（<code>5×5×64</code>）。</li>
<li>轮数 <code>n=24</code>。</li>
</ul>
</li>
<li><strong>流程</strong>：<ol>
<li>输入消息填充为 <code>r=1088</code> 比特的块（速率 <code>rate</code>）。</li>
<li>每个块异或到状态的前 <code>r</code> 比特，执行 Keccak-f[1600] 置换。</li>
<li>最终挤压出 256 比特哈希值。</li>
</ol>
</li>
</ul>
<hr>
<p><strong>6. 对比其他哈希函数的核心操作</strong></p>
<table>
<thead>
<tr>
<th><strong>哈希函数</strong></th>
<th><strong>核心操作</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SHA-3</td>
<td>Keccak-f 置换</td>
<td>基于比特操作，抗量子攻击，高灵活性</td>
</tr>
<tr>
<td>SHA-2</td>
<td>压缩函数（加法、布尔函数）</td>
<td>依赖算术运算（如模加），易受侧信道攻击</td>
</tr>
<tr>
<td>BLAKE3</td>
<td>置换 + 树形结构</td>
<td>高度并行，SIMD 优化</td>
</tr>
</tbody></table>
<hr>
<p><strong>总结</strong></p>
<p>Keccak-f 置换通过 <strong>多轮非线性变换</strong> 和 <strong>比特级混淆</strong>，为 SHA-3 提供了极高的安全性和效率。其设计平衡了抗攻击能力与实现灵活性，成为后量子时代哈希算法的标杆。</p>
<h2 id="内部采样循环"><a href="#内部采样循环" class="headerlink" title="内部采样循环"></a>内部采样循环</h2><p>接下来要优化的部分是这一段，也是最关键的一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++) &#123;</span><br><span class="line">    <span class="type">size_t</span> v = u + (j &lt;&lt; <span class="number">2</span>) + k;</span><br><span class="line">    <span class="type">uint64_t</span> lo = dec64le(buf.b + (k &lt;&lt; <span class="number">3</span>));</span><br><span class="line">    <span class="type">uint32_t</span> hi = dec16le(buf.b + <span class="number">32</span> + (k &lt;&lt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extract sign bit. */</span></span><br><span class="line">    <span class="type">uint32_t</span> neg = -(<span class="type">uint32_t</span>)(lo &gt;&gt; <span class="number">63</span>);</span><br><span class="line">    lo &amp;= <span class="number">0x7FFFFFFFFFFFFFFF</span>;</span><br><span class="line">    hi &amp;= <span class="number">0x7FFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use even or odd column depending on</span></span><br><span class="line"><span class="comment">       parity of t. */</span></span><br><span class="line">    <span class="type">uint32_t</span> pbit = (t[v &gt;&gt; <span class="number">3</span>] &gt;&gt; (v &amp; <span class="number">7</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> p_odd = -(<span class="type">uint64_t</span>)pbit;</span><br><span class="line">    <span class="type">uint32_t</span> p_oddw = (<span class="type">uint32_t</span>)p_odd;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hi_len; i += <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="type">uint64_t</span> tlo0 = tab_lo[i + <span class="number">0</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo1 = tab_lo[i + <span class="number">1</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo = tlo0</span><br><span class="line">      ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line">     <span class="type">uint32_t</span> cc =</span><br><span class="line">      (<span class="type">uint32_t</span>)((lo - tlo) &gt;&gt; <span class="number">63</span>);</span><br><span class="line">     <span class="type">uint32_t</span> thi0 = tab_hi[i + <span class="number">0</span>];</span><br><span class="line">     <span class="type">uint32_t</span> thi1 = tab_hi[i + <span class="number">1</span>];</span><br><span class="line">     <span class="type">uint32_t</span> thi = thi0</span><br><span class="line">      ^ (p_oddw &amp; (thi0 ^ thi1));</span><br><span class="line">     r += (hi - thi - cc) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> hinz = (hi - <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = hi_len; i &lt; lo_len; i += <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="type">uint64_t</span> tlo0 = tab_lo[i + <span class="number">0</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo1 = tab_lo[i + <span class="number">1</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo = tlo0</span><br><span class="line">      ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line">     <span class="type">uint32_t</span> cc =</span><br><span class="line">      (<span class="type">uint32_t</span>)((lo - tlo) &gt;&gt; <span class="number">63</span>);</span><br><span class="line">     r += hinz &amp; cc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Multiply by 2 and apply parity. */</span></span><br><span class="line">    r = (r &lt;&lt; <span class="number">1</span>) - p_oddw;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply sign bit. */</span></span><br><span class="line">    r = (r ^ neg) - neg;</span><br><span class="line"></span><br><span class="line">    x[v] = (<span class="type">int8_t</span>)*(<span class="type">int32_t</span> *)&amp;r;</span><br><span class="line">    sn += r * r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>因此我们要一步步来看。</p>
<h3 id="奇偶列构建"><a href="#奇偶列构建" class="headerlink" title="奇偶列构建"></a>奇偶列构建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v = u + (j &lt;&lt; <span class="number">2</span>) + k;</span><br><span class="line"><span class="type">uint64_t</span> lo = dec64le(buf.b + (k &lt;&lt; <span class="number">3</span>));</span><br><span class="line"><span class="type">uint32_t</span> hi = dec16le(buf.b + <span class="number">32</span> + (k &lt;&lt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract sign bit. */</span></span><br><span class="line"><span class="type">uint32_t</span> neg = -(<span class="type">uint32_t</span>)(lo &gt;&gt; <span class="number">63</span>);</span><br><span class="line">lo &amp;= <span class="number">0x7FFFFFFFFFFFFFFF</span>;</span><br><span class="line">hi &amp;= <span class="number">0x7FFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use even or odd column depending on</span></span><br><span class="line"><span class="comment">   parity of t. */</span></span><br><span class="line"><span class="type">uint32_t</span> pbit = (t[v &gt;&gt; <span class="number">3</span>] &gt;&gt; (v &amp; <span class="number">7</span>)) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="type">uint64_t</span> p_odd = -(<span class="type">uint64_t</span>)pbit;</span><br><span class="line"><span class="type">uint32_t</span> p_oddw = (<span class="type">uint32_t</span>)p_odd;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> r = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以细致的讲一下这些变量为什么要这么计算，由于开发者极其随意的命名风格，这些变量很难看出到底是什么和怎么计算，这也困扰了我相当长一段时间。</p>
<ul>
<li><p>变量v</p>
<p>v实际上是<strong>全局索引</strong>，它的计算方式是 <code>size_t v = u + (j &lt;&lt; 2) + k</code></p>
<p>其中：</p>
<ul>
<li><code>u</code>：外层循环变量，表示当前处理的样本块起始索引（步长16）。</li>
<li><code>j</code>：外层循环变量（0~3），对应四个并行的SHAKE实例。</li>
<li><code>k</code>：内层循环变量（0~3），对应每个SHAKE实例生成的4个样本。</li>
</ul>
<p>所以我们得知这里的<strong>处理逻辑</strong>是：</p>
<ul>
<li>每个SHAKE实例每次生成 <strong>4个样本</strong>（通过 <code>k</code> 循环）。</li>
<li>四个SHAKE实例（<code>j</code> 循环）共生成 <strong>16个样本</strong>（<code>4实例 × 4样本</code>）。</li>
<li>因此，<code>u</code> 每次递增16，处理下一个样本块。</li>
</ul>
<p>而<strong>全局索引</strong> <code>v</code> 的构造：</p>
<ul>
<li><code>(j &lt;&lt; 2)</code> 等价于 <code>j * 4</code>，表示每个SHAKE实例的样本偏移。</li>
<li><code>u + (j &lt;&lt; 2)</code> 表示当前SHAKE实例的起始索引。</li>
<li><code>k</code> 表示当前实例内的样本偏移。</li>
<li><strong>最终</strong>：<code>v</code> 的取值为 <code>0, 1, 2, ..., 2n-1</code>，覆盖所有样本。</li>
</ul>
</li>
<li><p>数组t</p>
<p><code>t</code> 数组是一个 <strong>紧凑的位数组</strong>，存储每个样本的 <strong>奇偶列选择位</strong>（<code>pbit</code>），即：</p>
<ul>
<li><code>pbit = 0</code>：选择高斯分布表的偶数列。</li>
<li><code>pbit = 1</code>：选择高斯分布表的奇数列。</li>
</ul>
<p>存储方式</p>
<ol>
<li><strong>每个样本占1位</strong>：<ul>
<li>每个样本的 <code>pbit</code> 只需1位（0或1），因此一个字节（8位）可以存储 <strong>8个样本</strong> 的 <code>pbit</code>。由于我们总共也就只要处理四个SHAKE实例即16个样本，因此两字节大小的t数组实际上就已经足够了。</li>
</ul>
</li>
<li><strong>索引计算</strong>：<ul>
<li><strong>字节索引</strong>：<code>v &gt;&gt; 3</code>（等价于 <code>v / 8</code>）。</li>
<li><strong>位偏移</strong>：<code>v &amp; 7</code>（等价于 <code>v % 8</code>）。</li>
</ul>
</li>
</ol>
</li>
<li><p>变量pbit</p>
<p>提取<strong>奇偶列选择位</strong>pbit: <code>uint32_t pbit = (t[v &gt;&gt; 3] &gt;&gt; (v &amp; 7)) &amp; 1;</code></p>
<ul>
<li>例如，样本 <code>v = 9</code>：<ul>
<li>字节索引：<code>9 &gt;&gt; 3 = 1</code> → 使用 <code>t[1]</code>。</li>
<li>位偏移：<code>9 &amp; 7 = 1</code> → 提取 <code>t[1]</code> 的第1位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>示例</strong></p>
<p>假设 <code>t</code> 数组内容为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">0</span>] = <span class="number">0b10101010</span>;<span class="comment">// 二进制，对应样本0~7的pbit</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="number">0b11001100</span>;<span class="comment">// 二进制，对应样本8~15的pbit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>样本 <code>v = 0</code>：<code>t[0]</code> 的第0位 → <code>0b10101010 &gt;&gt; 0 &amp; 1 = 0</code>。</li>
<li>样本 <code>v = 1</code>：<code>t[0]</code> 的第1位 → <code>0b10101010 &gt;&gt; 1 &amp; 1 = 1</code>。</li>
<li>样本 <code>v = 9</code>：<code>t[1]</code> 的第1位 → <code>0b11001100 &gt;&gt; 1 &amp; 1 = 0</code>。</li>
</ul>
<hr>
<p>在读懂这一部分之后，大家不免产生一个问题，那就是这个pbit变量明明只有0和1两种情况，一个bool类型也能表示了，为什么要用uint32_t类型？这不是浪费空间吗？答案是确实是这样的，取32位的作用纯粹是为了计算下面的两个掩码（没错，p_odd和p_oddw都是掩码，虽然odd的翻译是奇数，但我实在没想明白odd和掩码有什么关系）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> p_odd = -(<span class="type">uint64_t</span>)pbit;<span class="comment">//64位掩码</span></span><br><span class="line"><span class="type">uint32_t</span> p_oddw = (<span class="type">uint32_t</span>)p_odd;<span class="comment">//32位掩码</span></span><br></pre></td></tr></table></figure>

<p>这行代码的目的是将布尔值 <code>pbit</code>（0或1）转换为一个 <strong>全0或全1的64位掩码</strong>，具体规则如下：</p>
<ul>
<li>若 <code>pbit = 0</code>，则 <code>p_odd = 0x0000000000000000</code>（全0）。</li>
<li>若 <code>pbit = 1</code>，则 <code>p_odd = 0xFFFFFFFFFFFFFFFF</code>（全1）。</li>
</ul>
<p><strong>实现原理</strong></p>
<ol>
<li><strong>类型转换</strong>：<ul>
<li><code>(uint64_t)pbit</code>：将 <code>pbit</code>（0或1）强制转换为64位无符号整数。</li>
<li>此时结果为 <code>0x0000000000000000</code> 或 <code>0x0000000000000001</code>。</li>
</ul>
</li>
<li><strong>取负数操作</strong>：<ul>
<li>在补码表示中，负数 <code>x</code> 等价于 <code>~x + 1</code>（按位取反后加1）。</li>
<li>当 <code>pbit = 0</code> 时：<ul>
<li><code>0x0000000000000000 = 0x0000000000000000</code>（全0）。</li>
</ul>
</li>
<li>当 <code>pbit = 1</code> 时：<ul>
<li><code>0x0000000000000001 = 0xFFFFFFFFFFFFFFFF</code>（全1）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p>在上面的内容都能理解后。我们就可以得到AVX2指令集下的优化方案了。</p>
<p>首先，我们一次要并行处理四个SHAKE实例也就是十六个样本，因此可以直接取消掉j层循环，16个样本对应t数组的两个元素，u的步长是16所以取 <code>t[(u &gt;&gt; 3) + 0]</code>和 <code>t[(u &gt;&gt; 3) + 1]</code> 就可以得到两个字节了，但具体怎么使用这些奇偶位还需要结合后面的过程来分析。</p>
<h3 id="高斯分布查表"><a href="#高斯分布查表" class="headerlink" title="高斯分布查表"></a>高斯分布查表</h3><p>我们首先查看接下来的一段循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hi_len; i += <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="type">uint64_t</span> tlo0 = tab_lo[i + <span class="number">0</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo1 = tab_lo[i + <span class="number">1</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo = tlo0</span><br><span class="line">      ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line">     <span class="type">uint32_t</span> cc =</span><br><span class="line">      (<span class="type">uint32_t</span>)((lo - tlo) &gt;&gt; <span class="number">63</span>);</span><br><span class="line">     <span class="type">uint32_t</span> thi0 = tab_hi[i + <span class="number">0</span>];</span><br><span class="line">     <span class="type">uint32_t</span> thi1 = tab_hi[i + <span class="number">1</span>];</span><br><span class="line">     <span class="type">uint32_t</span> thi = thi0</span><br><span class="line">      ^ (p_oddw &amp; (thi0 ^ thi1));</span><br><span class="line">     r += (hi - thi - cc) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段看着全是赋值和运算，让人摸不清头脑。然而，这一段在逻辑上其实是四个条件选择结构。</p>
<p>我们可以把查表部分和运算部分先分离：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> tlo0 = tab_lo[i + <span class="number">0</span>];</span><br><span class="line"><span class="type">uint64_t</span> tlo1 = tab_lo[i + <span class="number">1</span>];</span><br><span class="line"><span class="type">uint32_t</span> thi0 = tab_hi[i + <span class="number">0</span>];</span><br><span class="line"><span class="type">uint32_t</span> thi1 = tab_hi[i + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">uint64_t</span> tlo = tlo0</span><br><span class="line"> ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line"><span class="type">uint32_t</span> cc =</span><br><span class="line"> (<span class="type">uint32_t</span>)((lo - tlo) &gt;&gt; <span class="number">63</span>);</span><br><span class="line"><span class="type">uint32_t</span> thi = thi0</span><br><span class="line"> ^ (p_oddw &amp; (thi0 ^ thi1));</span><br><span class="line">r += (hi - thi - cc) &gt;&gt; <span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<p>查表部分所查询的表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> sig_gauss_hi_Hawk_256[] = &#123;</span><br><span class="line"> <span class="number">0x4D70</span>, <span class="number">0x268B</span>,</span><br><span class="line"> <span class="number">0x0F80</span>, <span class="number">0x04FA</span>,</span><br><span class="line"> <span class="number">0x0144</span>, <span class="number">0x0041</span>,</span><br><span class="line"> <span class="number">0x000A</span>, <span class="number">0x0001</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> sig_gauss_lo_Hawk_256[] = &#123;</span><br><span class="line"> <span class="number">0x71FBD58485D45050</span>, <span class="number">0x1408A4B181C718B1</span>,</span><br><span class="line"> <span class="number">0x54114F1DC2FA7AC9</span>, <span class="number">0x614569CC54722DC9</span>,</span><br><span class="line"> <span class="number">0x42F74ADDA0B5AE61</span>, <span class="number">0x151C5CDCBAFF49A3</span>,</span><br><span class="line"> <span class="number">0x252E2152AB5D758B</span>, <span class="number">0x23460C30AC398322</span>,</span><br><span class="line"> <span class="number">0x0FDE62196C1718FC</span>, <span class="number">0x01355A8330C44097</span>,</span><br><span class="line"> <span class="number">0x00127325DDF8CEBA</span>, <span class="number">0x0000DC8DE401FD12</span>,</span><br><span class="line"> <span class="number">0x000008100822C548</span>, <span class="number">0x0000003B0FFB28F0</span>,</span><br><span class="line"> <span class="number">0x0000000152A6E9AE</span>, <span class="number">0x0000000005EFCD99</span>,</span><br><span class="line"> <span class="number">0x000000000014DA4A</span>, <span class="number">0x0000000000003953</span>,</span><br><span class="line"> <span class="number">0x000000000000007B</span>, <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些表中存储了累积分布的阈值，通过查表法达到近似高斯分布。因为一次查两个数据，因此循环步长为2。</p>
<p>来到运算部分，我们从之前的分析中得知，p_odd和p_oddw这二者要么全0要么全1，那么实际上可以做出这样的分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p_odd全0</span></span><br><span class="line">tlo = tlo0 ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line">--&gt; tlo = tlo0 ^ (<span class="number">0</span> &amp; (tlo0 ^ tlo1));</span><br><span class="line">--&gt; tlo = tlo0;</span><br><span class="line"><span class="comment">// p_odd全1</span></span><br><span class="line">tlo = tlo0 ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line">--&gt; tlo = tlo0 ^ (<span class="number">1</span> &amp; (tlo0 ^ tlo1));</span><br><span class="line">--&gt; tlo = tlo0 ^ tlo0 ^ tlo1;</span><br><span class="line">--&gt; tlo = tlo1;</span><br></pre></td></tr></table></figure>

<p>可见，这其实是根据p_odd的取值来为tlo赋值。thi的情况与其一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tlo = tlo0 ^ (p_odd &amp; (tlo0 ^ tlo1));  <span class="comment">// 等效于 p_odd ? tlo1 : tlo0</span></span><br><span class="line">thi = thi0 ^ (p_oddw &amp; (thi0 ^ thi1)); <span class="comment">// 等效于 p_oddw ? thi1 : thi0</span></span><br></pre></td></tr></table></figure>

<p>然后是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> cc = (<span class="type">uint32_t</span>)((lo - tlo) &gt;&gt; <span class="number">63</span>);</span><br><span class="line">r += (hi - thi - cc) &gt;&gt; <span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<p>cc的计算实际上也是一个低位比较。这里计算 <code>lo - tlo</code>的符号位（<code>cc</code>），若 <code>lo &lt; tlo</code>则 <code>cc = 1</code>，否则 <code>cc = 0</code>。也可以等效为 <code>cc = lo &lt; tlo ? 1:0;</code></p>
<p>而r的计算可以认为是高位比较结果的累加。r是在循环外定义的，这里计算计算 <code>hi - thi - cc</code>的符号位，若结果为负则累加 <code>1</code>到 <code>r</code>。</p>
<p>可能到这里大家有点忘了hi和lo是什么，因为这个函数里变量实在太多了。回忆一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> lo = dec64le(buf.b + (k &lt;&lt; <span class="number">3</span>));</span><br><span class="line"><span class="type">uint32_t</span> hi = dec16le(buf.b + <span class="number">32</span> + (k &lt;&lt; <span class="number">1</span>));</span><br><span class="line">lo &amp;= <span class="number">0x7FFFFFFFFFFFFFFF</span>;</span><br><span class="line">hi &amp;= <span class="number">0x7FFF</span>;</span><br></pre></td></tr></table></figure>

<p><code>lo</code><strong>：从随机字节流中提取的</strong> 64位无符号整数**，通过 <code>dec64le(buf.b + (k &lt;&lt; 3))</code> 解码（小端序），再置最高位为0。</p>
<p><code>hi</code><strong>：从随机字节流中提取的</strong> 16位无符号整数**，通过 <code>dec16le(buf.b + 32 + (k &lt;&lt; 1))</code> 解码（小端序），再置高17位为0。</p>
<p>两者共同构成一个 <strong>80位精度</strong> 的随机数（<code>hi</code>占高16位，<code>lo</code>占低64位）。</p>
<p>至于为什么要 <code>(k &lt;&lt; 3)</code>和 <code>(k &lt;&lt; 1)</code>，这里要回到结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> b[<span class="number">40</span>];   <span class="comment">// 40字节的原始字节流</span></span><br><span class="line">    <span class="type">uint16_t</span> w[<span class="number">20</span>];  <span class="comment">// 以16位（2字节）为单位解析</span></span><br><span class="line">    <span class="type">uint64_t</span> q[<span class="number">5</span>];   <span class="comment">// 以64位（8字节）为单位解析</span></span><br><span class="line">&#125; buf;</span><br></pre></td></tr></table></figure>

<p>这40字节的内存布局被设计为：</p>
<ul>
<li><strong>前32字节（<code>q[0]</code>~&#96;q[3]&#96;）</strong>：存储4个64位的 <code>lo</code> 值（每个占8字节）。</li>
<li><strong>后8字节（<code>q[4]</code>）</strong>：存储4个16位的 <code>hi</code> 值（每个占2字节），共8字节。</li>
</ul>
<p><code>(k &lt;&lt; 3)</code>和 <code>(k &lt;&lt; 1)</code>分别对代表8字节和2字节，是lo和hi每次取值时的字节步长。</p>
<hr>
<p><code>r</code>的值反映了随机数 <code>(hi, lo)</code>在表中连续区间的位置，最终用于生成采样值。</p>
<p>可以简略认为该函数作用是定位随机数在表中的位置。</p>
<p>接下来看下一段循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">uint32_t</span> hinz = (hi - <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = hi_len; i &lt; lo_len; i += <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="type">uint64_t</span> tlo0 = tab_lo[i + <span class="number">0</span>];</span><br><span class="line"> <span class="type">uint64_t</span> tlo1 = tab_lo[i + <span class="number">1</span>];</span><br><span class="line"> <span class="type">uint64_t</span> tlo = tlo0</span><br><span class="line">  ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line"> <span class="type">uint32_t</span> cc =</span><br><span class="line">  (<span class="type">uint32_t</span>)((lo - tlo) &gt;&gt; <span class="number">63</span>);</span><br><span class="line"> r += hinz &amp; cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们要理解这个 <code>hinz</code>是什么，虽然我很想解读其为 <code>hi_not_zero</code>，但不幸的是，它的意思恰好相反，首先hi是一个占了32位空间的16位无符号整数，那么当且仅当 <code>hi == 0</code> 时，<code>hi - 1</code> 的二进制为 <code>0xFFFF</code>（无符号溢出为最大值），右移31位后 <code>hinz = 1</code>。当 <code>hi &gt; 0</code> 时，<code>hi - 1</code> 是正数，右移31位后 <code>hinz = 0</code>。<code>0 &amp; cc</code> 等于0，所以当hinz等于0时，下面那个循环是没用的，也就是说，仅当hi等于0时，下面的循环才生效，又因为hi等于0了，只用计算低位比较即可。</p>
<p>我当然没想明白为什么开发者宁愿空转至少4个循环也不愿意写一个判断语句，这真的能更快的运行吗？tlo和cc甚至在上个循环结构中已经做出过判断了，我认为这一部分完全可以被合并到上个循环结构中。</p>
<hr>
<h3 id="奇偶性调整"><a href="#奇偶性调整" class="headerlink" title="奇偶性调整"></a><strong>奇偶性调整</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = (r &lt;&lt; <span class="number">1</span>) - p_oddw;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>操作分解</strong>：<ul>
<li><code>r &lt;&lt; 1</code>：将累加值 <code>r</code> 乘以2。</li>
<li><code>p_oddw</code>：减去奇偶标志（0或1）。</li>
</ul>
</li>
<li><strong>数学意义</strong>：<ul>
<li>当 <code>p_oddw = 0</code>（偶数列）：<code>r = 2r</code>，保持原权重。</li>
<li>当 <code>p_oddw = 1</code>（奇数列）：<code>r = 2r - 1</code>，调整权重以反映奇偶差异。</li>
</ul>
</li>
<li><strong>目的</strong>：根据奇偶性对采样值进行微调，可能用于处理对称分布的不同分支（如左右两侧概率不同）。</li>
</ul>
<hr>
<h3 id="符号处理"><a href="#符号处理" class="headerlink" title="符号处理"></a><strong>符号处理</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = (r ^ neg) - neg;</span><br></pre></td></tr></table></figure>

<ul>
<li>**变量 <code>neg</code>**：<ul>
<li><code>neg = -(uint32_t)(lo &gt;&gt; 63)</code>，即 <code>lo</code> 的最高位（符号位）为1时，<code>neg = 0xFFFFFFFF</code>（-1），否则 <code>neg = 0</code>。</li>
</ul>
</li>
<li><strong>操作分解</strong>：<ul>
<li>若 <code>neg = 0</code>：<code>r ^ 0 = r</code>，<code>r - 0 = r</code>，符号不变。</li>
<li>若 <code>neg = 0xFFFFFFFF</code>：<code>r ^ 0xFFFFFFFF</code> 等价于按位取反，再减去 <code>0xFFFFFFFF</code>（即加1），相当于 <code>r - 1 + 1 = -r</code>。</li>
</ul>
</li>
<li><strong>数学意义</strong>：将 <code>r</code> 转换为有符号数：<ul>
<li>若 <code>lo</code> 的符号位为1（<code>neg = -1</code>），则 <code>r = -r</code>。</li>
<li>否则保持 <code>r</code> 不变。</li>
</ul>
</li>
<li><strong>目的</strong>：根据随机数的符号位，确定采样值的正负，确保生成对称的高斯分布。</li>
</ul>
<hr>
<h3 id="存储采样值并累加平方和"><a href="#存储采样值并累加平方和" class="headerlink" title="存储采样值并累加平方和"></a><strong>存储采样值并累加平方和</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[v] = (<span class="type">int8_t</span>)*(<span class="type">int32_t</span> *)&amp;r;</span><br><span class="line">sn += r * r;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>强制类型转换</strong>：<ul>
<li><code>(int32_t *)&amp;r</code>：将 <code>r</code> 的地址解释为 <code>int32_t</code> 指针（确保符号扩展）。</li>
<li><code>(int8_t)</code>：截断为8位有符号整数。</li>
</ul>
</li>
<li><code>sn</code> 的作用：<ul>
<li><code>r * r</code> 计算采样值的平方。</li>
<li><code>sn</code> 累加所有采样值的平方和，可能用于后续验证（如计算范数或噪声水平）。</li>
</ul>
</li>
</ul>
<hr>
<p>以上，我们终于彻底讲清楚采样部分的代码原理，接下来开始进行优化。‘</p>
<h3 id="随机数选取"><a href="#随机数选取" class="headerlink" title="随机数选取"></a>随机数选取</h3><p>首先我们关注到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> b[<span class="number">40</span>];</span><br><span class="line">    <span class="type">uint16_t</span> w[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint64_t</span> q[<span class="number">5</span>];</span><br><span class="line">   &#125; buf;</span><br><span class="line">shake_extract(&amp;sc, buf.b, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">   __m256i avx2_view[<span class="number">5</span>];<span class="comment">//256位视图</span></span><br><span class="line">   <span class="type">uint64_t</span> u64_view[<span class="number">20</span>];<span class="comment">//64位视图</span></span><br><span class="line">  &#125; buf;</span><br><span class="line">shake_x4_extract_words(&amp;scx4, buf.u64_view, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>我们已经知道 <code>shake_x4_extract_words</code>是 <code>shake_extract</code>的并行版本，然而这其中却有着一些特点，如果在 <code>shake_extract</code>中使用四个连续的sc生成buf，若忽略覆盖问题，假设有四个独立的buf， 那么会生成四个连续的结果，但调用 <code>shake_x4_extract_words</code> 会从四个并行的 sc（scx4）中提取数据。他们输出的数据是完全一样的，但内存布局却是不一样的，具体表现为 <code>shake_x4_extract_words</code>产生的数据以 <strong>四个sc的交错顺序</strong> 存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果独立调用四次 shake_extract（每次提取一个 sc 的 5 个 uint64_t），则内存布局为：</span></span><br><span class="line">buf1_sc1.q[<span class="number">5</span>] = [sc1_1, sc1_2, sc1_3, sc1_4, sc1_5]  <span class="comment">// 第一个 `sc`</span></span><br><span class="line">buf2_sc2.q[<span class="number">5</span>] = [sc2_1, sc2_2, sc2_3, sc2_4, sc2_5]  <span class="comment">// 第二个 `sc`</span></span><br><span class="line">buf3_sc3.q[<span class="number">5</span>] = [sc3_1, sc3_2, sc3_3, sc3_4, sc3_5]  <span class="comment">// 第三个 `sc`</span></span><br><span class="line">buf4_sc4.q[<span class="number">5</span>] = [sc4_1, sc4_2, sc4_3, sc4_4, sc4_5]  <span class="comment">// 第四个 `sc`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而 shake_x4_extract_words 的布局是 将这四个独立缓冲区的数据按列展开。</span></span><br><span class="line">buf.u64_view[] = [</span><br><span class="line">    sc1_1, sc2_1, sc3_1, sc4_1, </span><br><span class="line">    sc1_2, sc2_2, sc3_2, sc4_2,  </span><br><span class="line">    sc1_3, sc2_3, sc3_3, sc4_3,  </span><br><span class="line">    sc1_4, sc2_4, sc3_4, sc4_4, </span><br><span class="line">    sc1_5, sc2_5, sc3_5, sc4_5,  </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们已知40字节的内存布局被设计为：</p>
<ul>
<li><strong>前32字节（<code>q[0]</code>~&#96;q[3]&#96;）</strong>：存储4个64位的 <code>lo</code> 值（每个占8字节）。</li>
<li><strong>后8字节（<code>q[4]</code>）</strong>：存储4个16位的 <code>hi</code> 值（每个占2字节），共8字节。。</li>
</ul>
<p>那么在 <code>buf.u64_view</code>下的内存布局将是</p>
<ul>
<li><strong>前128字节（</strong><code>avx2_view**[0]</code>~<strong><code>avx2_view**[3]</code>）</strong>：存储4个256位的 <code>lo</code> 值。<ul>
<li>每256位：被分为4个64位，分别存储sc1&#x2F;sc2&#x2F;sc3&#x2F;sc4的第n个 <code>lo</code>值。</li>
</ul>
</li>
<li><strong>后32字节（</strong><code>avx2_view**[4]</code>）**：存储1个256位的 <code>hi</code> 值。<ul>
<li>被分为4个64位，分别连续存储sc1&#x2F;sc2&#x2F;sc3&#x2F;sc4的所有 <code>hi</code>值。</li>
</ul>
</li>
</ul>
<p>于是我们先分离高位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__m256i avx2_256_hi = buf.avx2_view[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h3 id="主采样循环优化"><a href="#主采样循环优化" class="headerlink" title="主采样循环优化"></a>主采样循环优化</h3><p>首先我们把它99.9984741109375%(开玩笑的，受电磁干扰可能会置全0)都要空转的循环代码先合并：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> hinz = (hi - <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hi_len; i += <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="type">uint64_t</span> tlo0 = tab_lo[i + <span class="number">0</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo1 = tab_lo[i + <span class="number">1</span>];</span><br><span class="line">     <span class="type">uint64_t</span> tlo = tlo0</span><br><span class="line">      ^ (p_odd &amp; (tlo0 ^ tlo1));</span><br><span class="line">     <span class="type">uint32_t</span> cc =</span><br><span class="line">      (<span class="type">uint32_t</span>)((lo - tlo) &gt;&gt; <span class="number">63</span>);</span><br><span class="line">      <span class="type">uint32_t</span> thi0 = tab_hi[i + <span class="number">0</span>];</span><br><span class="line">      <span class="type">uint32_t</span> thi1 = tab_hi[i + <span class="number">1</span>];</span><br><span class="line">     <span class="type">uint32_t</span> thi = thi0</span><br><span class="line">      ^ (p_oddw &amp; (thi0 ^ thi1));</span><br><span class="line">     r += (hi - thi - cc) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">     r += hinz &amp; cc;<span class="comment">//尊重一下开发者不写if的优化方案</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过前面的分析，我们不难判断出，每一个 <code>pbit</code>都对应着一个64位无符号数。而由上面的内存布局来看，我们其实完全可以构建一个4*4的二维数组来存储并使用 <code>pbit</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建奇偶列</span></span><br><span class="line"><span class="type">int</span> pbit[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">  <span class="type">int</span> tmp = (i + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">  pbit[i][j] = ( t[tmp &gt;&gt; <span class="number">3</span>] &gt;&gt; (tmp &amp; <span class="number">7</span>) ) &amp; <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们也要创建 <code>neg</code>，这里我们要使用一个新的内联函数 <code>_mm256_cmpeq_epi64</code>，稍后做出介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line"> avx2_256_lo[i] = _mm256_and_si256(buf.avx2_view[i], avx2_256_lo_mask);</span><br><span class="line"> avx2_256_negative_mask[i] = _mm256_cmpeq_epi64(_mm256_srli_epi64(buf.avx2_view[i],<span class="number">63</span>), _mm256_set1_epi64x(<span class="number">0x1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>_mm256_cmpeq_epi64</code> 详解</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__m256i _mm256_cmpeq_epi64(__m256i a, __m256i b);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong></p>
<ul>
<li>对输入向量 <code>a</code> 和 <code>b</code> 中的每个 <strong>64 位有符号整数元素</strong> 进行相等比较。</li>
<li><strong>返回值</strong>：一个 256 位向量，每个 64 位元素根据比较结果设置：<ul>
<li>若 <code>a[i] == b[i]</code>，对应位置为全 1（<code>0xFFFFFFFFFFFFFFFF</code>）。</li>
<li>若 <code>a[i] != b[i]</code>，对应位置为全 0（<code>0x0000000000000000</code>）。</li>
</ul>
</li>
</ul>
<hr>
<p>同时也不能忽略高位为0的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__m256i avx2_256_hi_equals_zero = _mm256_srli_epi64(_mm256_cmpeq_epi64(avx2_256_hi, _mm256_setzero_si256()),<span class="number">63</span>);</span><br></pre></td></tr></table></figure>

<p>接下来要做的就是把循环结构并行化，我们在这里必须搞清楚，把64位无符号数作为操作基准，不然很容易陷入到混乱的思维中。（亲身经历）</p>
<p>首先，对于一个64位无符号数，必然有一个 <code>pbit</code>与之对应，又因为并行生成的 <code>buf</code>是交错存储结果的，无处理情况下，通过 <code>buf.avx2_view</code>获取到的256位变量实际上存储的是未优化情况下循环的第一个64位整数的集合，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc1_1, sc2_1, sc3_1, sc4_1</span><br></pre></td></tr></table></figure>

<p>而每一个64位无符号数要四次循环，选取 <code>tab</code>中的值进行运算来确定随机数在高斯分布表的位置，因此我们可以做如下优化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">    __m256i avx2_256_tab_low = _mm256_setr_epi64x(</span><br><span class="line">     tab_lo[pbit[i][<span class="number">0</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">1</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">2</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">3</span>] + <span class="number">2</span> * j]);</span><br><span class="line">    __m256i avx2_256_tab_hi = _mm256_setr_epi64x(</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">0</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">1</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">2</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">3</span>] + <span class="number">2</span> * j]);</span><br><span class="line">    __m256i avx2_256_cc = _mm256_srli_epi64(_mm256_sub_epi64(avx2_256_lo[i], avx2_256_tab_low),<span class="number">63</span>);</span><br><span class="line">    sna1 = _mm256_add_epi64(_mm256_srli_epi64(_mm256_sub_epi64(avx2_256_hi,</span><br><span class="line">     _mm256_add_epi64(avx2_256_cc, avx2_256_tab_hi)),<span class="number">63</span>), sna1);</span><br><span class="line">    sna1 = _mm256_add_epi64(_mm256_and_si256(avx2_256_hi_equals_zero,avx2_256_cc),sna1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们一共要完成对16个无符号数的处理，而通过AVX2指令我们得以一次完成对四个无符号数的处理。但我们仍然需要一次外循环来帮助我们处理完16个数，同时我们要完成对 <code>sna</code>的处理，<code>sna1</code>是针对与一个整数进行计算的结果，而 <code>sna</code>则是全局的累加结果。也不能忽略掉 <code>x</code>对 <code>sna</code>1的存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">    __m256i avx2_256_tab_low = _mm256_setr_epi64x(</span><br><span class="line">     tab_lo[pbit[i][<span class="number">0</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">1</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">2</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">3</span>] + <span class="number">2</span> * j]);</span><br><span class="line">    __m256i avx2_256_tab_hi = _mm256_setr_epi64x(</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">0</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">1</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">2</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">3</span>] + <span class="number">2</span> * j]);</span><br><span class="line">    __m256i avx2_256_cc = _mm256_srli_epi64(_mm256_sub_epi64(avx2_256_lo[i], avx2_256_tab_low),<span class="number">63</span>);</span><br><span class="line">    sna1 = _mm256_add_epi64(_mm256_srli_epi64(_mm256_sub_epi64(avx2_256_hi,</span><br><span class="line">     _mm256_add_epi64(avx2_256_cc, avx2_256_tab_hi)),<span class="number">63</span>), sna1);</span><br><span class="line">    sna1 = _mm256_add_epi64(_mm256_and_si256(avx2_256_hi_equals_zero,avx2_256_cc),sna1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sna1 = _mm256_sub_epi64(_mm256_slli_epi64(sna1,<span class="number">1</span>),_mm256_setr_epi64x(</span><br><span class="line">    pbit[i][<span class="number">0</span>],</span><br><span class="line">    pbit[i][<span class="number">1</span>],</span><br><span class="line">    pbit[i][<span class="number">2</span>],</span><br><span class="line">    pbit[i][<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">   sna1 = _mm256_sub_epi64(_mm256_xor_epi64(sna1, avx2_256_negative_mask[i]), avx2_256_negative_mask[i]);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = _mm256_extract_epi32(sna1, <span class="number">2</span> * j);</span><br><span class="line">    x[<span class="number">4</span> * i + j] = (<span class="type">int8_t</span>)*(<span class="type">int32_t</span> *)&amp;tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sna = _mm256_add_epi64(_mm256_mullo_epi64(sna1,sna1),sna);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>完成这些后。该函数的优化工作就已经完成了，以下是优化后的函数整体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">sig_gauss</span><span class="params">(<span class="type">unsigned</span> logn,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> (*rng)(<span class="type">void</span> *ctx, <span class="type">void</span> *dst, <span class="type">size_t</span> len), <span class="type">void</span> *rng_context,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> shake_context *sc_extra, <span class="type">int8_t</span> *x, <span class="type">const</span> <span class="type">uint8_t</span> *t)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">uint16_t</span> *tab_hi;</span><br><span class="line"> <span class="type">const</span> <span class="type">uint64_t</span> *tab_lo;</span><br><span class="line"> <span class="type">size_t</span> hi_len, lo_len;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span> (logn) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">  tab_hi = sig_gauss_hi_Hawk_256;</span><br><span class="line">  tab_lo = sig_gauss_lo_Hawk_256;</span><br><span class="line">  hi_len = SG_MAX_HI_Hawk_256;</span><br><span class="line">  lo_len = SG_MAX_LO_Hawk_256;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">  tab_hi = sig_gauss_hi_Hawk_512;</span><br><span class="line">  tab_lo = sig_gauss_lo_Hawk_512;</span><br><span class="line">  hi_len = SG_MAX_HI_Hawk_512;</span><br><span class="line">  lo_len = SG_MAX_LO_Hawk_512;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>: <span class="comment">/* 10 */</span></span><br><span class="line">  tab_hi = sig_gauss_hi_Hawk_1024;</span><br><span class="line">  tab_lo = sig_gauss_lo_Hawk_1024;</span><br><span class="line">  hi_len = SG_MAX_HI_Hawk_1024;</span><br><span class="line">  lo_len = SG_MAX_LO_Hawk_1024;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">size_t</span> n = (<span class="type">size_t</span>)<span class="number">1</span> &lt;&lt; logn;</span><br><span class="line"> <span class="type">uint8_t</span> seed[<span class="number">41</span>];</span><br><span class="line"> rng(rng_context, seed, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化四个SHAKE上下文并inject</span></span><br><span class="line"> shake_context sc[<span class="number">4</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (sc_extra != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   sc[i] = *sc_extra;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   shake_init(&amp;sc[i], <span class="number">256</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  seed[<span class="number">40</span>] = (<span class="type">uint8_t</span>)i;</span><br><span class="line">  shake_inject(&amp;sc[i], seed, <span class="number">41</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> shake_x4_context scx4;</span><br><span class="line"> shake_x4_flip(&amp;scx4, sc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置掩码</span></span><br><span class="line"> __m256i avx2_256_hi_mask = _mm256_set1_epi64x(<span class="number">0x7FFF</span>);</span><br><span class="line"> __m256i avx2_256_lo_mask = _mm256_set1_epi64x(<span class="number">0x7FFFFFFFFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置平方范数累加器 Square norm accumulator</span></span><br><span class="line"> __m256i sna = _mm256_setzero_si256();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">size_t</span> u = <span class="number">0</span>; u &lt; (n &lt;&lt; <span class="number">1</span>); u += <span class="number">16</span>) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">   __m256i avx2_view[<span class="number">5</span>];<span class="comment">//256位视图</span></span><br><span class="line">   <span class="type">uint64_t</span> u64_view[<span class="number">20</span>];<span class="comment">//64位视图</span></span><br><span class="line">  &#125; buf;</span><br><span class="line"></span><br><span class="line">  shake_x4_extract_words(&amp;scx4, buf.u64_view, <span class="number">5</span>);</span><br><span class="line">  __m256i avx2_256_hi = _mm256_and_si256(buf.avx2_view[<span class="number">4</span>], avx2_256_hi_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建奇偶列</span></span><br><span class="line">  <span class="type">int</span> pbit[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = (i + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">    pbit[i][j] = ( t[tmp &gt;&gt; <span class="number">3</span>] &gt;&gt; (tmp &amp; <span class="number">7</span>) ) &amp; <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __m256i avx2_256_hi_equals_zero = _mm256_srli_epi64(_mm256_cmpeq_epi64(avx2_256_hi, _mm256_setzero_si256()),<span class="number">63</span>);</span><br><span class="line"></span><br><span class="line">  __m256i avx2_256_lo[<span class="number">4</span>];</span><br><span class="line">  __m256i avx2_256_negative_mask[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">   avx2_256_lo[i] = _mm256_and_si256(buf.avx2_view[i], avx2_256_lo_mask);</span><br><span class="line">   avx2_256_negative_mask[i] = _mm256_cmpeq_epi64(_mm256_srli_epi64(buf.avx2_view[i],<span class="number">63</span>), _mm256_set1_epi64x(<span class="number">0x1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __m256i sna1 = _mm256_setzero_si256();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">    __m256i avx2_256_tab_low = _mm256_setr_epi64x(</span><br><span class="line">     tab_lo[pbit[i][<span class="number">0</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">1</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">2</span>] + <span class="number">2</span> * j],</span><br><span class="line">     tab_lo[pbit[i][<span class="number">3</span>] + <span class="number">2</span> * j]);</span><br><span class="line">    __m256i avx2_256_tab_hi = _mm256_setr_epi64x(</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">0</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">1</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">2</span>] + <span class="number">2</span> * j],</span><br><span class="line">     (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">3</span>] + <span class="number">2</span> * j]);</span><br><span class="line">    __m256i avx2_256_cc = _mm256_srli_epi64(_mm256_sub_epi64(avx2_256_lo[i], avx2_256_tab_low),<span class="number">63</span>);</span><br><span class="line">    sna1 = _mm256_add_epi64(_mm256_srli_epi64(_mm256_sub_epi64(avx2_256_hi,</span><br><span class="line">     _mm256_add_epi64(avx2_256_cc, avx2_256_tab_hi)),<span class="number">63</span>), sna1);</span><br><span class="line">    sna1 = _mm256_add_epi64(_mm256_and_si256(avx2_256_hi_equals_zero,avx2_256_cc),sna1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sna1 = _mm256_sub_epi64(_mm256_slli_epi64(sna1,<span class="number">1</span>),_mm256_setr_epi64x(</span><br><span class="line">    pbit[i][<span class="number">0</span>],</span><br><span class="line">    pbit[i][<span class="number">1</span>],</span><br><span class="line">    pbit[i][<span class="number">2</span>],</span><br><span class="line">    pbit[i][<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">   sna1 = _mm256_sub_epi64(_mm256_xor_epi64(sna1, avx2_256_negative_mask[i]), avx2_256_negative_mask[i]);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = _mm256_extract_epi32(sna1, <span class="number">2</span> * j);</span><br><span class="line">    x[<span class="number">4</span> * i + j] = (<span class="type">int8_t</span>)*(<span class="type">int32_t</span> *)&amp;tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sna = _mm256_add_epi64(_mm256_mullo_epi64(sna1,sna1),sna);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在与这个函数鏖战数日之后，我决定致敬一下开发者，把乘法都换成位运算。以下是修正后并添加了注释的版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 高斯采样核心函数（使用AVX2加速） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">sig_gauss</span><span class="params">(<span class="type">unsigned</span> logn,</span></span><br><span class="line"><span class="params">          <span class="type">void</span> (*rng)(<span class="type">void</span> *ctx, <span class="type">void</span> *dst, <span class="type">size_t</span> len), <span class="type">void</span> *rng_context,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> shake_context *sc_extra, <span class="type">int8_t</span> *x, <span class="type">const</span> <span class="type">uint8_t</span> *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 高斯分布表指针和长度 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> *tab_hi;  <span class="comment">// 高位数分布表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> *tab_lo;  <span class="comment">// 低位数分布表</span></span><br><span class="line">    <span class="type">size_t</span> hi_len, lo_len;   <span class="comment">// 分布表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据安全级别选择预计算的高斯分布表 */</span></span><br><span class="line">    <span class="keyword">switch</span> (logn)  <span class="comment">// logn决定密码学方案的安全级别</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:  <span class="comment">// 256位安全级别</span></span><br><span class="line">        tab_hi = sig_gauss_hi_Hawk_256;</span><br><span class="line">        tab_lo = sig_gauss_lo_Hawk_256;</span><br><span class="line">        hi_len = SG_MAX_HI_Hawk_256;</span><br><span class="line">        lo_len = SG_MAX_LO_Hawk_256;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:  <span class="comment">// 512位安全级别</span></span><br><span class="line">        tab_hi = sig_gauss_hi_Hawk_512;</span><br><span class="line">        tab_lo = sig_gauss_lo_Hawk_512;</span><br><span class="line">        hi_len = SG_MAX_HI_Hawk_512;</span><br><span class="line">        lo_len = SG_MAX_LO_Hawk_512;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 10 */</span>  <span class="comment">// 1024位安全级别</span></span><br><span class="line">        tab_hi = sig_gauss_hi_Hawk_1024;</span><br><span class="line">        tab_lo = sig_gauss_lo_Hawk_1024;</span><br><span class="line">        hi_len = SG_MAX_HI_Hawk_1024;</span><br><span class="line">        lo_len = SG_MAX_LO_Hawk_1024;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化基础参数 */</span></span><br><span class="line">    <span class="type">size_t</span> n = (<span class="type">size_t</span>)<span class="number">1</span> &lt;&lt; logn;  <span class="comment">// 计算向量维度：n = 2^logn</span></span><br><span class="line">    <span class="type">uint8_t</span> seed[<span class="number">41</span>];              <span class="comment">// 随机种子缓冲区（40字节随机数 + 1字节标识）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成随机种子 */</span></span><br><span class="line">    rng(rng_context, seed, <span class="number">40</span>);  <span class="comment">// 调用随机数生成器填充40字节种子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化四个SHAKE上下文并inject</span></span><br><span class="line">    shake_context sc[<span class="number">4</span>];  <span class="comment">// 4个并行SHAKE上下文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 上下文初始化：继承或新建 */</span></span><br><span class="line">        <span class="keyword">if</span> (sc_extra != <span class="literal">NULL</span>)  <span class="comment">// 如果存在外部上下文</span></span><br><span class="line">        &#123;</span><br><span class="line">            sc[i] = *sc_extra;  <span class="comment">// 直接复制已有上下文</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 否则初始化新上下文</span></span><br><span class="line">        &#123;</span><br><span class="line">            shake_init(&amp;sc[i], <span class="number">256</span>);  <span class="comment">// 初始化256位安全级别的SHAKE</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 注入带标识的种子 */</span></span><br><span class="line">        seed[<span class="number">40</span>] = (<span class="type">uint8_t</span>)i;         <span class="comment">// 最后1字节设置为上下文标识</span></span><br><span class="line">        shake_inject(&amp;sc[i], seed, <span class="number">41</span>); <span class="comment">// 注入41字节种子（40+1）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 初始化四路并行处理上下文 */</span></span><br><span class="line">    shake_x4_context scx4;          <span class="comment">// 四路并行处理结构</span></span><br><span class="line">    shake_x4_flip(&amp;scx4, sc);       <span class="comment">// 转换到输出模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AVX2掩码初始化 */</span></span><br><span class="line">    __m256i avx2_256_hi_mask = _mm256_set1_epi64x(<span class="number">0x7FFF</span>);          <span class="comment">// 高位掩码（保留15位）</span></span><br><span class="line">    __m256i avx2_256_lo_mask = _mm256_set1_epi64x(<span class="number">0x7FFFFFFFFFFFFFFF</span>); <span class="comment">// 低位掩码（保留63位）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 平方范数累加器初始化 */</span></span><br><span class="line">    __m256i sna = _mm256_setzero_si256();  <span class="comment">// 使用256位SIMD寄存器存储累加值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主处理循环：每次处理16个元素 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> u = <span class="number">0</span>; u &lt; (n &lt;&lt; <span class="number">1</span>); u += <span class="number">16</span>)  <span class="comment">// 总处理量是2n，步长16</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 随机数据缓冲区（联合体实现双视图访问） */</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            __m256i avx2_view[<span class="number">5</span>];  <span class="comment">// AVX2向量视图（5个256位寄存器）</span></span><br><span class="line">            <span class="type">uint64_t</span> u64_view[<span class="number">20</span>]; <span class="comment">// 等价于20个64位整数值</span></span><br><span class="line">        &#125; buf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从四路SHAKE上下文中提取随机数据 */</span></span><br><span class="line">        shake_x4_extract_words(&amp;scx4, buf.u64_view, <span class="number">5</span>);  <span class="comment">// 提取5个256位数据块</span></span><br><span class="line">        __m256i avx2_256_hi = _mm256_and_si256(buf.avx2_view[<span class="number">4</span>], avx2_256_hi_mask);  <span class="comment">// 处理第5个块的高位部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构建4x4奇偶校验位矩阵 */</span></span><br><span class="line">        <span class="type">int</span> pbit[<span class="number">4</span>][<span class="number">4</span>];  <span class="comment">// 奇偶校验位存储矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)  <span class="comment">// 列循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)  <span class="comment">// 行循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = (i + <span class="number">1</span>) * (j + <span class="number">1</span>);  <span class="comment">// 计算t数组的索引位置</span></span><br><span class="line">                pbit[i][j] = (t[tmp &gt;&gt; <span class="number">3</span>] &gt;&gt; (tmp &amp; <span class="number">7</span>)) &amp; <span class="number">1</span>;  <span class="comment">// 位操作提取特定位（tmp/8字节，tmp%8位）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计算高位部分是否为零的条件掩码 */</span></span><br><span class="line">        __m256i avx2_256_hi_equals_zero = _mm256_srli_epi64(</span><br><span class="line">            _mm256_cmpeq_epi64(avx2_256_hi, _mm256_setzero_si256()), <span class="number">63</span>);  <span class="comment">// 生成64位全1掩码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 准备AVX2运算数据 */</span></span><br><span class="line">        __m256i avx2_256_lo[<span class="number">4</span>];          <span class="comment">// 低位数据存储</span></span><br><span class="line">        __m256i avx2_256_negative_mask[<span class="number">4</span>]; <span class="comment">// 符号位掩码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)  <span class="comment">// 处理前4个256位块</span></span><br><span class="line">        &#123;</span><br><span class="line">            avx2_256_lo[i] = _mm256_and_si256(buf.avx2_view[i], avx2_256_lo_mask);  <span class="comment">// 提取低位数据</span></span><br><span class="line">            avx2_256_negative_mask[i] = _mm256_cmpeq_epi64(</span><br><span class="line">                _mm256_srli_epi64(buf.avx2_view[i], <span class="number">63</span>), _mm256_set1_epi64x(<span class="number">0x1</span>)); <span class="comment">// 提取符号位（1表示负数）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 临时平方范数累加器 */</span></span><br><span class="line">        __m256i sna1 = _mm256_setzero_si256();  <span class="comment">// 每轮计算的临时累加</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 四通道并行处理 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)  <span class="comment">// 处理4个通道</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)  <span class="comment">// 每个通道4个步骤</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 加载高斯分布表值（低64位） */</span></span><br><span class="line">                __m256i avx2_256_tab_low = _mm256_setr_epi64x(</span><br><span class="line">                    tab_lo[pbit[i][<span class="number">0</span>] + (j &lt;&lt; <span class="number">1</span>)],  <span class="comment">// 通道0的表索引</span></span><br><span class="line">                    tab_lo[pbit[i][<span class="number">1</span>] + (j &lt;&lt; <span class="number">1</span>)],  <span class="comment">// 通道1的表索引</span></span><br><span class="line">                    tab_lo[pbit[i][<span class="number">2</span>] + (j &lt;&lt; <span class="number">1</span>)],  <span class="comment">// 通道2的表索引</span></span><br><span class="line">                    tab_lo[pbit[i][<span class="number">3</span>] + (j &lt;&lt; <span class="number">1</span>)]); <span class="comment">// 通道3的表索引</span></span><br><span class="line">    </span><br><span class="line">                <span class="comment">/* 加载高斯分布表值（高16位转64位） */</span></span><br><span class="line">                __m256i avx2_256_tab_hi = _mm256_setr_epi64x(</span><br><span class="line">                    (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">0</span>] + (j &lt;&lt; <span class="number">1</span>)],  <span class="comment">// 高位扩展</span></span><br><span class="line">                    (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">1</span>] + (j &lt;&lt; <span class="number">1</span>)],</span><br><span class="line">                    (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">2</span>] + (j &lt;&lt; <span class="number">1</span>)],</span><br><span class="line">                    (<span class="type">uint64_t</span>)tab_hi[pbit[i][<span class="number">3</span>] + (j &lt;&lt; <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 计算进位标志 */</span></span><br><span class="line">                __m256i avx2_256_cc = _mm256_srli_epi64(</span><br><span class="line">                    _mm256_sub_epi64(avx2_256_lo[i], avx2_256_tab_low), <span class="number">63</span>); <span class="comment">// 比较低位差值的符号位</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 更新临时累加器 */</span></span><br><span class="line">                sna1 = _mm256_add_epi64(</span><br><span class="line">                    _mm256_srli_epi64(</span><br><span class="line">                        _mm256_sub_epi64(avx2_256_hi, _mm256_add_epi64(avx2_256_cc, avx2_256_tab_hi)), </span><br><span class="line">                        <span class="number">63</span>), </span><br><span class="line">                    sna1);  <span class="comment">// 高位差值的符号位累加</span></span><br><span class="line">                sna1 = _mm256_add_epi64(</span><br><span class="line">                    _mm256_and_si256(avx2_256_hi_equals_zero, avx2_256_cc), </span><br><span class="line">                    sna1);  <span class="comment">// 高位为零时的进位累加</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 调整累加器符号 */</span></span><br><span class="line">            sna1 = _mm256_sub_epi64(</span><br><span class="line">                _mm256_slli_epi64(sna1, <span class="number">1</span>),  <span class="comment">// 左移1位（乘2）</span></span><br><span class="line">                _mm256_setr_epi64x(         <span class="comment">// 减去奇偶校验位</span></span><br><span class="line">                    pbit[i][<span class="number">0</span>],</span><br><span class="line">                    pbit[i][<span class="number">1</span>],</span><br><span class="line">                    pbit[i][<span class="number">2</span>],</span><br><span class="line">                    pbit[i][<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 应用符号掩码 */</span></span><br><span class="line">            sna1 = _mm256_sub_epi64(</span><br><span class="line">                _mm256_xor_epi64(sna1, avx2_256_negative_mask[i]), </span><br><span class="line">                avx2_256_negative_mask[i]);  <span class="comment">// 根据符号位调整正负号</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 存储采样结果到输出数组 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)  <span class="comment">// 处理4个通道结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint32_t</span> tmp = _mm256_extract_epi32(sna1, <span class="number">2</span> * j);  <span class="comment">// 提取32位中间结果</span></span><br><span class="line">                x[(j &lt;&lt; <span class="number">1</span>) + j] = (<span class="type">int8_t</span>)*(<span class="type">int32_t</span> *)&amp;tmp;        <span class="comment">// 转换为8位有符号整数存储</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新平方范数累加器 */</span></span><br><span class="line">            sna = _mm256_add_epi64(</span><br><span class="line">                _mm256_mullo_epi64(sna1, sna1),  <span class="comment">// 计算平方</span></span><br><span class="line">                sna);  <span class="comment">// 累加到总平方和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>说实话，连着做了几天这个函数，没有一点感想是不可能的，事实上，最后完成优化的部分并没有多长，反而是之前为了理解这个函数的作用，理解变量的意义（尤其在作者命名意义不明的时候），源代码在一部分程度上的优化（比如位运算），理解源代码对内存布局的安排花了大量的学习时间和思考时间，即便到现在我认为我已经完成了对这个函数的优化，但我仍然不能完全理解这个函数某些计算的意义，恐怕还得恶补大量的数学基础才能更加进一步的优化了。但我时间有限，还要完成对其他许多函数的优化，而且开发者在注释中提及的也大概是这个方向，只能到此为止了。不过这段时间的花费绝非没有意义。虽然有点折磨和费脑子，但确实能够提升我在这个方向上的知识和工作能力。最少也产出了这篇记录，不至于之后回头来看不懂自己的代码了😂</p>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2025-03-03</p></div> 
    <div class="post-entry__tags"><a href="/SeverusBlog/tags/AVX2/" class="post-tags__link button"># AVX2</a><a href="/SeverusBlog/tags/Hawk/" class="post-tags__link button"># Hawk</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/SeverusBlog/2025/03/09/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-ENCODE-01/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            上一篇
                        </div>
                        <div class="nav__title">
                            签名部分优化-ENCODE-01
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/SeverusBlog/2025/02/27/%E7%AD%BE%E5%90%8D%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96-GAUSS-03/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            下一篇
                        </div>
                        <div class="nav__title">
                            签名部分优化-GAUSS-03
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>



    <div class="post__comments post__with-toc content-card" id="comment">
        
    <h4>评论</h4>
    
    
    
    <div id="valine_container" class="valine_thread"></div>

    
    
    
    
    
    
    
    
    
    



    </div>



</main>

            <footer class="footer">
    
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2025 <a href="/SeverusBlog/">Severus&#39; Blog Site</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

 



 



 


    
 

 

 

 

 

 


    

    

    
    
    <script>
        function loadComment() {
            let e;
            (e = document.createElement("script")).src = 'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
            document.body.appendChild(e);
            e.onload = () => {
                var valineConfig = {"appId":"g22hZmqJ9HDVUEHYgPs16NJN-gzGzoHsz","appKey":"ulaHsmJDpXSbv2NxdT9YGgb2","placeholder":null,"path":null,"avatar":null,"meta":["nick","mail","link"],"pageSize":null,"lang":null,"visitor":null,"highlight":null,"avatarForce":null,"recordIP":null,"serverURLs":null,"enableQQ":true,"requiredFields":["nick","mail"],"emojiCDN":null,"emojiMaps":null};
                valineConfig.el = '#valine_container';
                for (var i in valineConfig) {
                    if (valineConfig[i] === null) delete valineConfig[i];
                }
                new Valine(valineConfig);
            };
        }
    
        var runningOnBrowser = typeof window !== "undefined";
        var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
        var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
    
        setTimeout(function () {
            if (!isBot && supportsIntersectionObserver) {
                var comment_observer = new IntersectionObserver(function(entries) {
                    if (entries[0].isIntersecting) {
                        loadComment();
                        comment_observer.disconnect();
                    }
                }, { threshold: [0] });
                comment_observer.observe(document.getElementById('comment'));
            } else {
                loadComment();
            }
        }, 1);
    </script>


    
    
    
    
    

    
    
    
    
    

    
    
    



    </body>
</html>
